{"version":3,"sources":["angular-animate.js","angular-ui-router.js","angular-resource.js","angular-jwt.js","angular-slugify.js","angular-sortable-view.js","toaster.js"],"names":["window","angular","undefined","assertArg","arg","name","reason","ngMinErr","mergeClasses","a","b","isArray","join","packageStyles","options","styles","to","from","pendClasses","classes","fix","isPrefix","className","isString","length","split","forEach","klass","i","removeFromArray","arr","val","index","indexOf","splice","stripCommentsFromElement","element","jqLite","nodeType","ELEMENT_NODE","extractElementNode","elm","$$addClass","$$jqLite","addClass","$$removeClass","removeClass","applyAnimationClassesFactory","prepareAnimationOptions","$$prepared","domOperation","noop","$$domOperationFired","applyAnimationStyles","applyAnimationFromStyles","applyAnimationToStyles","css","mergeAnimationOptions","target","newOptions","toAdd","toRemove","resolveElementClasses","attr","extend","existing","splitClassesToLookup","obj","ADD_CLASS","REMOVE_CLASS","flags","value","key","prop","allow","getDomNode","computeCssStyles","$window","properties","Object","create","detectedStyles","getComputedStyle","formalStyleName","actualStyleName","c","charAt","parseMaxTime","str","maxValue","values","substring","parseFloat","Math","max","truthyTimingValue","getCssTransitionDurationStyle","duration","applyOnlyDuration","style","TRANSITION_PROP","DURATION_KEY","getCssKeyframeDurationStyle","ANIMATION_DURATION_PROP","getCssDelayStyle","delay","isKeyframeAnimation","ANIMATION_DELAY_PROP","TRANSITION_DELAY_PROP","blockTransitions","node","applyInlineStyle","blockKeyframeAnimations","applyBlock","ANIMATION_PROP","ANIMATION_PLAYSTATE_KEY","styleTuple","createLocalCacheLookup","cache","flush","count","entry","total","get","put","TRANSITIONEND_EVENT","ANIMATIONEND_EVENT","isObject","isUndefined","isDefined","isFunction","isElement","NG_ANIMATE_CLASSNAME","NG_ANIMATE_CHILDREN_DATA","$$rAFSchedulerFactory","$$rAF","scheduler","tasks","tickQueue","push","concat","nextTick","updatedQueue","innerQueue","runNextTask","cancelFn","nextTask","shift","waitUntilQuiet","fn","$$AnimateChildrenDirective","scope","attrs","ngAnimateChildren","data","$observe","CSS_PREFIX","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","PROPERTY_KEY","DELAY_KEY","TIMING_KEY","ANIMATION_ITERATION_COUNT_KEY","ELAPSED_TIME_MAX_DECIMAL_PLACES","CLOSING_TIME_BUFFER","ONE_SECOND","SAFE_FAST_FORWARD_DURATION_VALUE","TRANSITION_DURATION_PROP","DETECT_CSS_PROPERTIES","transitionDuration","transitionDelay","transitionProperty","animationDuration","animationDelay","animationIterationCount","DETECT_STAGGER_CSS_PROPERTIES","$AnimateCssProvider","$animateProvider","gcsLookup","gcsStaggerLookup","this","$get","$$AnimateRunner","$timeout","$document","$sniffer","$$rAFScheduler","gcsHashFn","extraClasses","KEY","parentNode","parentID","parentCounter","getAttribute","computeCachedCssStyles","cacheKey","timings","computeCachedCssStaggerStyles","stagger","staggerClassName","callback","rafWaitQueue","width","bod","offsetWidth","computeTimings","aD","tD","maxDelay","maxDuration","init","endFn","close","rejected","animationClosed","animationCompleted","animationPaused","setupClasses","activeClasses","temporaryStyles","applyAnimationClasses","onDone","runner","complete","applyBlocking","blockTransition","blockKeyframeAnimation","closeAndReturnNoopAnimator","end","cancel","$$willAnimate","start","triggerAnimationStart","recalculateTimingStyles","fullClassName","relativeDelay","hasTransitions","hasAnimations","applyTransitionDelay","applyAnimationDelay","delayStyle","maxDelayTime","maxDurationTime","easing","easeProp","easeVal","events","startTime","Date","now","on","onAnimationProgress","onAnimationExpired","event","stopPropagation","ev","originalEvent","timeStamp","$manualTimeStamp","elapsedTime","toFixed","playPause","playAnimation","maxStagger","itemIndex","floor","runnerHost","resume","pause","animations","transitions","method","isStructural","structural","structuralClassName","addRemoveClassName","applyClassesEarly","trim","hasToStyles","keys","containsKeyframeAnimation","keyframeStyle","staggerVal","transitionStyle","durationStyle","staggerIndex","isFirst","hasTransitionAll","applyTransitionDuration","applyAnimationDuration","skipBlocking","body","$$AnimateCssDriverProvider","$$animationProvider","drivers","NG_ANIMATE_SHIM_CLASS_NAME","NG_ANIMATE_ANCHOR_CLASS_NAME","NG_OUT_ANCHOR_CLASS_NAME","NG_IN_ANCHOR_CLASS_NAME","$animateCss","$rootScope","$rootElement","filterCssClasses","replace","getUniqueValues","filter","prepareAnchoredAnimation","outAnchor","inAnchor","calculateAnchorStyles","anchor","coords","getBoundingClientRect","bodyNode","scrollTop","scrollLeft","prepareOutAnimation","animator","clone","getClassVal","prepareInAnimation","endingClasses","startingClasses","remove","cloneNode","rootBodyElement","append","animatorIn","animatorOut","startingAnimator","currentAnimation","done","prepareFromToAnchorAnimation","anchors","fromAnimation","prepareRegularAnimation","toAnimation","anchorAnimations","outElement","inElement","animationRunners","animation","all","status","animationDetails","rootNode","$$AnimateJsProvider","$injector","$$rAFMutex","lookupAnimations","matches","flagMap","animationFactory","$$registeredAnimations","applyOptions","executeAnimationFn","args","classesToAdd","classesToRemove","apply","groupEventedAnimations","fnName","operations","ani","endProgressCb","resolved","onAnimationComplete","result","cancelled","packageAnimations","runners","animateFn","reject","arguments","before","after","afterFn","beforeFn","toUpperCase","substr","onComplete","success","endAnimations","closeActiveAnimations","chain","$$AnimateJsDriverProvider","$$animateJs","prepareAnimation","endFnFactory","NG_ANIMATE_ATTR_NAME","NG_ANIMATE_PIN_DATA","$$AnimateQueueProvider","isAllowed","ruleType","previousAnimation","rules","some","hasAnimationClasses","and","PRE_DIGEST_STATE","RUNNING_STATE","skip","newAnimation","state","nO","cO","$$HashMap","$$animation","$templateRequest","normalizeAnimationOptions","findCallbacks","targetNode","entries","callbackRegistry","contains","triggerCallback","phase","queueAnimation","notifyProgress","progress","parent","isAnimatableClassName","skipAnimations","animationsEnabled","disabledElementsLookup","existingAnimation","activeAnimationsLookup","hasExistingAnimation","areAnimationsAllowed","closeChildAnimations","skipAnimationFlag","cancelAnimationFlag","joinAnimationFlag","isValidAnimation","clearElementAnimationState","closeParentClassBasedAnimations","counter","markElementAnimationState","$$postDigest","animationCancelled","parentElement","realRunner","setHost","children","querySelectorAll","child","parseInt","removeAttribute","isMatchingElement","nodeOrElmA","nodeOrElmB","startingElement","examineParentAnimation","animateChildren","bodyElementDetected","rootElementDetected","parentAnimationDetected","parentHost","details","bodyElement","allowAnimation","setAttribute","oldValue","newValue","deregisterWatch","$watch","totalPendingRequests","isEmpty","classNameFilter","test","container","off","filterFromRegistry","list","matchContainer","matchCallback","containerNode","isMatch","pin","enabled","bool","argCount","hasElement","recordExists","$$rAFMutexFactory","passed","$$AnimateRunnerFactory","$q","AnimateRunner","host","_doneCallbacks","_runInAnimationFrame","_state","INITIAL_STATE","DONE_PENDING_STATE","DONE_COMPLETE_STATE","next","response","onProgress","prototype","getPromise","promise","self","resolve","then","resolveHandler","rejectHandler","catch","handler","finally","_resolve","$$AnimationProvider","setRunner","RUNNER_STORAGE_KEY","removeRunner","removeData","getRunner","NG_ANIMATE_REF_ATTR","animationQueue","totalPendingClassBasedAnimations","totalActiveClassBasedAnimations","classBasedAnimationsQueue","getAnchorNodes","SELECTOR","items","hasAttribute","groupAnimations","preparedAnimations","refLookup","enterOrMove","anchorNodes","direction","animationID","usedIndicesLookup","anchorGroups","indexKey","toString","lookupKey","group","beforeStart","cssClassesIntersection","out","in","aa","j","invokeFirstDriver","driverName","has","factory","driver","tempClasses","updateAnimationRunners","newRunner","update","handleDestroyedElement","classBasedIndex","animationEntry","startAnimationFn","closeFn","targetElement","operation","animationRunner","sort","map","module","directive","provider","exports","inherit","extra","merge","dst","hasOwnProperty","ancestors","first","second","path","n","objectKeys","object","array","Array","Number","len","ceil","inheritParams","currentParams","newParams","$current","$to","parentParams","parents","inherited","inheritList","params","equalForKeys","k","filterByKeys","filtered","pick","copy","slice","call","omit","collection","$Resolve","VISIT_IN_PROGRESS","VISIT_DONE","NOTHING","NO_DEPENDENCIES","NO_LOCALS","NO_PARENT","when","$$promises","$$values","study","invocables","visit","visited","cycle","Error","plan","annotate","param","pop","isResolve","invocableKeys","locals","wait","merged","$$inheritedValues","resolution","fail","$$failure","invoke","invocable","onfailure","invocation","proceed","e","defer","waitParams","dep","promises","ii","$TemplateFactory","$http","$templateCache","fromConfig","config","template","fromString","templateUrl","fromUrl","templateProvider","fromProvider","url","headers","Accept","UrlMatcher","pattern","parentMatcher","addParameter","id","type","location","paramNames","$$UMFP","Param","quoteRegExp","string","squash","optional","surroundPattern","matchDetails","m","isSearch","regexp","segment","cfg","last","RegExp","caseInsensitive","placeholder","searchPlaceholder","compiled","segments","$$new","ParamSet","source","p","exec","isOptional","lastIndex","search","sourceSearch","sourcePath","strict","prefix","$$paramNames","Type","$UrlMatcherFactory","valToString","valFromString","getDefaultConfig","isStrictMode","isCaseInsensitive","isInjectable","flushTypeQueue","typeQueue","$types","injector","def","defaultSquashPolicy","enqueue","defaultTypes","encode","decode","is","int","date","getFullYear","getMonth","getDate","match","capture","isNaN","valueOf","equals","toISOString","json","toJson","fromJson","any","identity","$$getDefaultValue","strictMode","compile","isMatcher","o","definition","definitionFn","unwrapShorthand","isShorthand","$$fn","getType","urlType","getArrayMode","arrayDefaults","arrayParamNomenclature","getSquashPolicy","getReplace","arrayMode","configuredKeys","defaultPolicy","item","defaultValue","$value","hasReplaceVal","$replace","replacement","$normalize","$asArray","dynamic","$$parent","$$keys","ignore","reverse","paramset","paramValues","$$equals","paramValues1","paramValues2","equal","left","right","$$validates","rawVal","normalized","encoded","$UrlRouterProvider","$locationProvider","$urlMatcherFactory","regExpPrefix","re","interpolate","what","handleIfMatch","$match","$location","$browser","appendBasePath","isHtml5","absolute","baseHref","evt","check","rule","handled","defaultPrevented","lastPushedUrl","otherwise","listen","listener","$on","interceptDeferred","sync","read","urlMatcher","format","$$avoidResync","href","validates","html5Mode","hashPrefix","slash","port","protocol","redirect","handlerIsString","strategies","matcher","regex","global","sticky","deferIntercept","$inject","$StateProvider","$urlRouterProvider","isRelative","stateName","findState","stateOrName","base","isStr","rel","pathLength","current","states","queueState","parentName","queue","flushQueuedChildren","queued","registerState","lastIndexOf","stateBuilder","$delegates","abstractKey","$stateParams","$state","navigable","transitionTo","isGlob","text","doesStateMatchGlob","glob","globSegments","l","unshift","MAX_VALUE","decorator","func","$view","$resolve","$urlRouter","handleRedirect","$broadcast","TransitionAborted","retry","$retry","TransitionFailed","retryTransition","transition","TransitionSuperseded","toParams","resolveState","paramsAreFiltered","resolveViews","viewsPromises","views","view","injectables","$template","load","globals","notify","controllerProvider","injectLocals","$$controller","controller","$$state","$$controllerAs","controllerAs","TransitionPrevented","root","reload","go","relative","fromParams","fromPath","toState","hash","redirectResult","toPath","keep","toLocals","reloadState","ownParams","shouldSkipReload","entering","exiting","onExit","onEnter","error","includes","lossy","nav","context","nonSearchParamsEqual","fromAndToState","notSearchParam","nonQueryParamKeys","nonQueryParams","nonQueryParamSet","reloadOnSearch","compositeName","abstract","$ViewProvider","$templateFactory","defaults","async","$ViewScrollProvider","useAnchorScroll","$anchorScroll","$element","scrollIntoView","$ViewDirective","$uiViewScroll","$interpolate","getService","service","getRenderer","statics","enter","cb","leave","$animate","$animator","animate","restrict","terminal","priority","transclude","tElement","tAttrs","$transclude","cleanupLastView","previousEl","currentScope","$destroy","currentEl","renderer","updateView","firstTime","newScope","getUiViewName","previousLocals","latestLocals","$new","$emit","autoScrollExp","$eval","onloadExp","onload","autoscroll","$ViewDirectiveFill","$compile","$controller","initial","html","link","contents","$scope","uiView","inheritedData","parseStateRef","ref","parsed","preparsed","paramExpr","stateContext","el","stateData","$StateRefDirective","allowedOptions","require","uiSrefActive","uiSref","hrefKind","newHref","isAnchor","isForm","nodeName","optionsOverride","uiSrefOpts","option","newVal","activeDirective","$$addStateInfo","$set","oldVal","bind","button","which","ctrlKey","metaKey","shiftKey","preventDefault","ignorePreventDefaultCount","$StateRefActiveDirective","$attrs","anyMatch","activeClass","uiSrefActiveEq","newState","$IsStateFilter","isFilter","$stateful","$IncludedByStateFilter","includesFilter","defaultConfig","searchParams","decodePathArray","reverseString","unquoteDashes","allReversed","paramName","parameters","nTotal","nPath","paramVal","encodeDashes","encodeURIComponent","charCodeAt","isPathParam","isDefaultValue","nextSegment","$subPattern","sub","mode","ArrayType","bindTo","callbackName","arrayWrap","arrayUnwrap","falsey","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","$arrayMode","run","isValidDottedPath","MEMBER_NAME_REGEX","lookupDottedPath","$resourceMinErr","shallowClearAndCopy","src","$$minErr","stripTrailingSlashes","actions","save","query","delete","encodeUriSegment","encodeUriQuery","pctEncodeSpaces","Route","urlParams","resourceFactory","paramDefaults","extractParams","actionParams","ids","defaultResponseInterceptor","resource","Resource","route","toJSON","$promise","$resolved","action","hasBody","a1","a2","a3","a4","isInstanceCall","httpConfig","responseInterceptor","interceptor","responseErrorInterceptor","responseError","setUrlParams","additionalParamDefaults","actionUrl","encodedVal","_","urlParam","p1","leadingSlashes","tail","authHeader","authPrefix","tokenGetter","request","skipAuthorization","tokenPromise","token","urlBase64Decode","output","decodeURIComponent","escape","atob","decodeToken","parts","decoded","JSON","parse","getTokenExpirationDate","exp","d","setUTCSeconds","isTokenExpired","offsetSeconds","_slugify","s","ch","cp","ascii","String","fromCharCode","charmap","toLowerCase","mod"," ","¡","¢","£","¥","¦","§","¨","©","ª","«","¬","­","®","°","±","²","³","´","µ","¶","·","¸","¹","º","»","¼","½","¾","¿","À","Á","Â","Ã","Ä","Å","Æ","Ç","È","É","Ê","Ë","Ì","Í","Î","Ï","Ð","Ñ","Ò","Ó","Ô","Õ","Ö","×","Ø","Ù","Ú","Û","Ü","Ý","Þ","ß","à","á","â","ã","ä","å","æ","ç","è","é","ê","ë","ì","í","î","ï","ð","ñ","ò","ó","ô","õ","ö","÷","ø","ù","ú","û","ü","ý","þ","ÿ","Ā","ā","Ă","ă","Ą","ą","Ć","ć","Ĉ","ĉ","Ċ","ċ","Č","č","Ď","ď","Đ","đ","Ē","ē","Ĕ","ĕ","Ė","ė","Ę","ę","Ě","ě","Ĝ","ĝ","Ğ","ğ","Ġ","ġ","Ģ","ģ","Ĥ","ĥ","Ħ","ħ","Ĩ","ĩ","Ī","ī","Ĭ","ĭ","Į","į","İ","ı","Ĳ","ĳ","Ĵ","ĵ","Ķ","ķ","Ĺ","ĺ","Ļ","ļ","Ľ","ľ","Ŀ","ŀ","Ł","ł","Ń","ń","Ņ","ņ","Ň","ň","ŉ","Ō","ō","Ŏ","ŏ","Ő","ő","Œ","œ","Ŕ","ŕ","Ŗ","ŗ","Ř","ř","Ś","ś","Ŝ","ŝ","Ş","ş","Š","š","Ţ","ţ","Ť","ť","Ŧ","ŧ","Ũ","ũ","Ū","ū","Ŭ","ŭ","Ů","ů","Ű","ű","Ų","ų","Ŵ","ŵ","Ŷ","ŷ","Ÿ","Ź","ź","Ż","ż","Ž","ž","ſ","slugify","Slug","elem","$parent","input","touchFix","touches","clientX","clientY","getPreviousSibling","previousElementSibling","sib","previousSibling","insertElementBefore","newElement","prevSibl","prepend","elementMatchesSelector","selector","matchingFunction","shouldBeAfter","pointer","isGrid","x","y","getSortableElements","ROOTS_MAP","removeSortableElements","sortingInProgress","$parse","mapKey","svRoot","$id","candidates","$placeholder","$helper","$original","$target","onSort","svOnSort","svOnStart","$$element","attributes","svOnStop","onStart","onStop","svGrid","$watchCollection","part","getPart","top","dict","$moveUpdate","opts","mouse","svElement","svOriginal","svPlaceholder","originatingPart","originatingIndex","svRect","tolerance","height","$part","model","$index","$item","$root","$$phase","$apply","reposition","document","offset","se","containment","rect","center","scrollHeight","scrollWidth","q","targetIndex","getIndex","querySelector","pRect","pCenter","cand","$drop","afterRevert","spliced","$partTo","$partFrom","$indexTo","$indexFrom","revert","placeholderRect","helperRect","distance","sqrt","pow","min","setTimeout","addToSortableElements","removeFromSortableElements","elems","$ctrl","$sortableRoot","$sortable","svPart","assign","sortablePart","$controllers","onMousedown","onMousemove","moveExecuted","pointerOffset","containmentRect","closestElement","clientRect","helper","targetLeft","targetTop","mouseup","sortableElement","handle","customHandle","customHelper","customPlaceholder","documentElement","add","head","dde","matchesSelector","webkitMatches","webkitMatchesSelector","msMatches","msMatchesSelector","mozMatches","mozMatchesSelector","closest","res","constant","limit","tap-to-dismiss","close-button","newest-on-top","time-out","icon-classes","info","warning","body-output-type","body-template","icon-class","position-class","title-class","message-class","prevent-duplicates","mouseover-timer-stop","toasterConfig","title","timeout","bodyOutputType","clickHandler","toasterId","showCloseButton","toastId","onHideCallback","toast","uid","clear","toasterType","toasterFactory","deregisterNewToast","deregisterClearToasts","newToastEventSubscribers","clearToastsEventSubscribers","setup","subscribeToNewToastEvent","onNewToast","subscribeToClearToastsEvent","onClearToasts","unsubscribeToNewToastEvent","unsubscribeToClearToastsEvent","$interval","$sce","toaster","toasterEventRegistry","time","timeoutPromise","removeToast","addToast","mergedConfig","isUndefinedOrNull","toasters","closeButton","closeButtonForType","trustAsHtml","bodyTemplate","fcGet","templateWithData","configureTimer","toastIndex","removeAllToasts","toasterOptions","position","message","tap","mouseoverTimer","_onNewToast","_onClearToasts","isNumber","stopTimer","restartTimer","click","isCloseButton","console","log"],"mappings":"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K,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,IACLC,IAAK,KACLC,IAAK,IACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,IACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,IACLC,IAAK,IACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,KACLC,IAAK,KACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,KACLC,IAAK,KACLC,IAAK,IACLC,IAAK,IACLC,IAAK,KACLC,IAAK,KACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,KACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,KACLC,IAAK,KACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,IACLC,IAAK,KACLC,IAAK,IACLC,IAAK,IACLC,IAAK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","file":"vendors.min.js","sourcesContent":["/**\n * @license AngularJS v1.4.3\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* jshint ignore:start */\nvar noop        = angular.noop;\nvar extend      = angular.extend;\nvar jqLite      = angular.element;\nvar forEach     = angular.forEach;\nvar isArray     = angular.isArray;\nvar isString    = angular.isString;\nvar isObject    = angular.isObject;\nvar isUndefined = angular.isUndefined;\nvar isDefined   = angular.isDefined;\nvar isFunction  = angular.isFunction;\nvar isElement   = angular.isElement;\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\nvar isPromiseLike = function(p) {\n  return p && p.then ? true : false;\n}\n\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return '';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(' ');\n  if (isArray(b)) b = b.join(' ');\n  return a + ' ' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = '';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? ' ' : '';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return [];\n        break;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it's important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n        break;\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType == ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  }\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationOptions(element, target, newOptions) {\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\n  extend(target, newOptions);\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: '',\n    removeClass: ''\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = 'addClass';\n      allow = !existing[klass];\n    } else if (val === REMOVE_CLASS) {\n      prop = 'removeClass';\n      allow = existing[klass];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += ' ';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(' ');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof angular.element) ? element[0] : element;\n}\n\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n  var tickQueue = [];\n  var cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    tickQueue.push([].concat(tasks));\n    nextTick();\n  }\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncancelled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!tickQueue.length) return;\n\n    var updatedQueue = [];\n    for (var i = 0; i < tickQueue.length; i++) {\n      var innerQueue = tickQueue[i];\n      runNextTask(innerQueue);\n      if (innerQueue.length) {\n        updatedQueue.push(innerQueue);\n      }\n    }\n    tickQueue = updatedQueue;\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n\n  function runNextTask(tasks) {\n    var nextTask = tasks.shift();\n    nextTask();\n  }\n}];\n\nvar $$AnimateChildrenDirective = [function() {\n  return function(scope, element, attrs) {\n    var val = attrs.ngAnimateChildren;\n    if (angular.isString(val) && val.length === 0) { //empty attribute\n      element.data(NG_ANIMATE_CHILDREN_DATA, true);\n    } else {\n      attrs.$observe('ngAnimateChildren', function(value) {\n        value = value === 'on' || value === 'true';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      });\n    }\n  };\n}];\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and stlyes may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transition` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n * `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occuring on the classes being added and removed.)\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n  CSS_PREFIX = '-webkit-';\n  TRANSITION_PROP = 'WebkitTransition';\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n  TRANSITION_PROP = 'transition';\n  TRANSITIONEND_EVENT = 'transitionend';\n}\n\nif (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n  CSS_PREFIX = '-webkit-';\n  ANIMATION_PROP = 'WebkitAnimation';\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n  ANIMATION_PROP = 'animation';\n  ANIMATIONEND_EVENT = 'animationend';\n}\n\nvar DURATION_KEY = 'Duration';\nvar PROPERTY_KEY = 'Property';\nvar DELAY_KEY = 'Delay';\nvar TIMING_KEY = 'TimingFunction';\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\nvar ONE_SECOND = 1000;\nvar BASE_TEN = 10;\n\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\n\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === '-' || c === '+' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for zegative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it's always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) == 's') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + 's';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += ' linear all';\n  }\n  return [style, value];\n}\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + 's'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + 's'];\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? '-' + duration + 's' : '';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? 'paused' : '';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\nvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n               '$document', '$sniffer', '$$rAFScheduler',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $document,   $sniffer,   $$rAFScheduler) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = \"$$ngAnimateParentKey\";\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === 'infinite') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we're keeping an interal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, '-stagger');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var bod = getDomNode($document).body;\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        //the line below will force the browser to perform a repaint so\n        //that all the animated elements within the animation frame will\n        //be properly updated and drawn on screen. This is required to\n        //ensure that the preparation animation is properly flushed so that\n        //the active state picks up from there. DO NOT REMOVE THIS LINE.\n        //DO NOT OPTIMIZE THIS LINE. THE MINIFIER WILL REMOVE IT OTHERWISE WHICH\n        //WILL RESULT IN AN UNPREDICTABLE BUG THAT IS VERY HARD TO TRACK DOWN AND\n        //WILL TAKE YEARS AWAY FROM YOUR LIFE.\n        var width = bod.offsetWidth + 1;\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](width);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    return init;\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    function init(element, options) {\n      var node = getDomNode(element);\n      if (!node || !node.parentNode) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      var temporaryStyles = [];\n      var classes = element.attr('class');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(' ')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = '';\n      var addRemoveClassName = '';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, 'ng-', true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, '-add');\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += ' ';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, '-remove');\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n        addRemoveClassName = '';\n      }\n\n      var setupClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n      var fullClassName = classes + ' ' + setupClasses;\n      var activeClasses = pendClasses(setupClasses, '-active');\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !setupClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, setupClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      $$jqLite.addClass(element, setupClasses);\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      applyAnimationFromStyles(element, options);\n      if (!flags.blockTransition) {\n        blockTransitions(node, false);\n      }\n\n      applyBlocking(maxDuration);\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don't have access to pause/resume the animation\n          // since it hasn't run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) { // jshint ignore:line\n        // if the promise has been called already then we shouldn't close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        $$jqLite.removeClass(element, setupClasses);\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = '';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        var startTime, events = [];\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              animationPaused\n                  ? temporaryStyles.push(value)\n                  : removeFromArray(temporaryStyles, value);\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidently cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intential stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.className + ' ' + setupClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyTransitionDelay || flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n\n            var delayStyle;\n            if (flags.applyTransitionDelay) {\n              timings.transitionDelay = relativeDelay;\n              delayStyle = getCssDelayStyle(relativeDelay);\n              temporaryStyles.push(delayStyle);\n              node.style[delayStyle[0]] = delayStyle[1];\n            }\n\n            if (flags.applyAnimationDelay) {\n              timings.animationDelay = relativeDelay;\n              delayStyle = getCssDelayStyle(relativeDelay, true);\n              temporaryStyles.push(delayStyle);\n              node.style[delayStyle[0]] = delayStyle[1];\n            }\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          element.on(events.join(' '), onAnimationProgress);\n          $timeout(onAnimationExpired, maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime);\n\n          applyAnimationToStyles(element, options);\n        }\n\n        function onAnimationExpired() {\n          // although an expired animation is a failed animation, getting to\n          // this outcome is very easy if the CSS code screws up. Therefore we\n          // should still continue normally as if the animation completed correctly.\n          close();\n        }\n\n        function onAnimationProgress(event) {\n          event.stopPropagation();\n          var ev = event.originalEvent || event;\n          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();\n\n          /* Firefox (or possibly just Gecko) likes to not round values up\n           * when a ms measurement is used for the animation */\n          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n          /* $manualTimeStamp is a mocked timeStamp value which is set\n           * within browserTrigger(). This is only here so that tests can\n           * mock animations properly. Real events fallback to event.timeStamp,\n           * or, if they don't, then a timeStamp is automatically created for them.\n           * We're checking to see if the timeStamp surpasses the expected delay,\n           * but we're using elapsedTime instead of the timeStamp on the 2nd\n           * pre-condition since animations sometimes close off early */\n          if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n            // we set this flag to ensure that if the transition is paused then, when resumed,\n            // the animation will automatically close itself since transitions cannot be paused.\n            animationCompleted = true;\n            close();\n          }\n        }\n      }\n    }\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateCssDriver');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$document', '$sniffer',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $document,   $sniffer) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = getDomNode($document).body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(bodyNode.parentNode === rootNode ? bodyNode : rootNode);\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, '');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(' ');\n      if (isString(b)) b = b.split(' ');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(' ');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn't return\n        // all the keys for the coods object when iterated\n        forEach(['width','height','top','left'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case 'top':\n              value += bodyNode.scrollTop;\n              break;\n            case 'left':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + 'px';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr('class') || '';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from);\n      var toAnimation = prepareRegularAnimation(to);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor['out'];\n        var inElement = anchor['in'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        // structural animations ensure that the CSS classes are always applied\n        // before the detection starts.\n        options.structural = options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        options.event = animationDetails.event;\n        if (options.event === 'leave') {\n          options.onDone = options.domOperation;\n        }\n      } else {\n        options.event = null;\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {\n  this.$get = ['$injector', '$$AnimateRunner', '$$rAFMutex', '$$jqLite',\n       function($injector,   $$AnimateRunner,   $$rAFMutex,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, 'enter');\n    return function(element, event, classes, options) {\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element's className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr('class') || '';\n        if (options.addClass) {\n          classes += ' ' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += ' ' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don't return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event == 'leave') {\n          beforeFn = 'leave';\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== 'enter' && event !== 'move') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      return {\n        start: function() {\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          var animationClosed = false;\n          var runner = new $$AnimateRunner({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            animationClosed = true;\n            applyOptions();\n            applyAnimationStyles(element, options);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case 'animate':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case 'setClass':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case 'addClass':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case 'removeClass':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a,b;\n          if (fnName === 'beforeSetClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n          } else if (fnName === 'setClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              reject ? runner.cancel() : runner.end();\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(' ');\n      var matches = [], flagMap = {};\n      for (var i=0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateJsDriver');\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\nvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(element, currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(options, and) {\n    options = options || {};\n    var a = (options.addClass || '').length > 0;\n    var b = (options.removeClass || '').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(element, newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event == 'leave' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // if there is a current animation then skip the class-based animation\n    return currentAnimation.structural && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    var nO = newAnimation.options;\n    var cO = currentAnimation.options;\n\n    // if the exact same CSS class is added/removed then it's safe to cancel it\n    return (nO.addClass && nO.addClass === cO.removeClass) || (nO.removeClass && nO.removeClass === cO.addClass);\n  });\n\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite) {\n\n    var activeAnimationsLookup = new $$HashMap();\n    var disabledElementsLookup = new $$HashMap();\n\n    var animationsEnabled = null;\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it's important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var bodyElement = jqLite($document[0].body);\n\n    var callbackRegistry = {};\n\n    // remember that the classNameFilter is set during the provider/config\n    // stage therefore we can optimize here and setup a helper function\n    var classNameFilter = $animateProvider.classNameFilter();\n    var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationOptions(element, options) {\n      return mergeAnimationOptions(element, options, {});\n    }\n\n    function findCallbacks(element, event) {\n      var targetNode = getDomNode(element);\n\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (entry.node.contains(targetNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    function triggerCallback(event, element, phase, data) {\n      $$rAF(function() {\n        forEach(findCallbacks(element, event), function(callback) {\n          callback(element, phase, data);\n        });\n      });\n    }\n\n    return {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n      },\n\n      off: function(event, container, callback) {\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n\n        function filterFromRegistry(list, matchContainer, matchCallback) {\n          var containerNode = extractElementNode(matchContainer);\n          return list.filter(function(entry) {\n            var isMatch = entry.node === containerNode &&\n                            (!matchCallback || entry.callback === matchCallback);\n            return !isMatch;\n          });\n        }\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), 'element', 'not an element');\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n            var recordExists = disabledElementsLookup.get(node);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !recordExists;\n            } else {\n              // (element, bool) - Element setter\n              bool = !!bool;\n              if (!bool) {\n                disabledElementsLookup.put(node, true);\n              } else if (recordExists) {\n                disabledElementsLookup.remove(node);\n              }\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    function queueAnimation(element, event, options) {\n      var node, parent;\n      element = stripCommentsFromElement(element);\n      if (element) {\n        node = getDomNode(element);\n        parent = element.parent();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // there are situations where a directive issues an animation for\n      // a jqLite wrapper that contains only comment nodes... If this\n      // happens then there is no way we can perform an animation\n      if (!node) {\n        close();\n        return runner;\n      }\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(' ');\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(' ');\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      var className = [node.className, options.addClass, options.removeClass].join(' ');\n      if (!isAnimatableClassName(className)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // this is a hard disable of all animations for the application or on\n      // the element itself, therefore  there is no need to continue further\n      // past this point if not enabled\n      var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(element, parent, event);\n      }\n\n      if (skipAnimations) {\n        close();\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(element);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationOptions(element, existingAnimation.options, options);\n            return existingAnimation.runner;\n          }\n        }\n\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn't started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the existing animation options into this new follow-up animation\n            mergeAnimationOptions(element, newAnimation.options, existingAnimation.options);\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationOptions(element, options);\n            } else {\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n              return runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationOptions(element, options);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation.options);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(element);\n        return runner;\n      }\n\n      if (isStructural) {\n        closeParentClassBasedAnimations(parent);\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === 'animate'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails.options));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it's the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn't allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won't read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(element);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true)\n            ? 'setClass'\n            : animationDetails.event;\n\n        if (animationDetails.structural) {\n          closeParentClassBasedAnimations(parentElement);\n        }\n\n        markElementAnimationState(element, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(getDomNode(element));\n          }\n          notifyProgress(runner, event, 'close', {});\n        });\n\n        // this will update the runner's flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, 'start', {});\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        triggerCallback(event, element, phase, data);\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) { // jshint ignore:line\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(element) {\n      var node = getDomNode(element);\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n        var animationDetails = activeAnimationsLookup.get(child);\n        switch (state) {\n          case RUNNING_STATE:\n            animationDetails.runner.end();\n            /* falls through */\n          case PRE_DIGEST_STATE:\n            if (animationDetails) {\n              activeAnimationsLookup.remove(child);\n            }\n            break;\n        }\n      });\n    }\n\n    function clearElementAnimationState(element) {\n      var node = getDomNode(element);\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.remove(node);\n    }\n\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n    }\n\n    function closeParentClassBasedAnimations(startingElement) {\n      var parentNode = getDomNode(startingElement);\n      do {\n        if (!parentNode || parentNode.nodeType !== ELEMENT_NODE) break;\n\n        var animationDetails = activeAnimationsLookup.get(parentNode);\n        if (animationDetails) {\n          examineParentAnimation(parentNode, animationDetails);\n        }\n\n        parentNode = parentNode.parentNode;\n      } while (true);\n\n      // since animations are detected from CSS classes, we need to flush all parent\n      // class-based animations so that the parent classes are all present for child\n      // animations to properly function (otherwise any CSS selectors may not work)\n      function examineParentAnimation(node, animationDetails) {\n        // enter/leave/move always have priority\n        if (animationDetails.structural || !hasAnimationClasses(animationDetails.options)) return;\n\n        if (animationDetails.state === RUNNING_STATE) {\n          animationDetails.runner.end();\n        }\n        clearElementAnimationState(node);\n      }\n    }\n\n    function areAnimationsAllowed(element, parentElement, event) {\n      var bodyElementDetected = false;\n      var rootElementDetected = false;\n      var parentAnimationDetected = false;\n      var animateChildren;\n\n      var parentHost = element.data(NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentElement = parentHost;\n      }\n\n      while (parentElement && parentElement.length) {\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n        }\n\n        var parentNode = parentElement[0];\n        if (parentNode.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentNode) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can't allow any animations to take place\n        // but if a parent animation is class-based then that's ok\n        if (!parentAnimationDetected) {\n          parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode);\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n          if (!rootElementDetected) {\n            parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);\n            if (parentHost) {\n              parentElement = parentHost;\n            }\n          }\n        }\n\n        if (!bodyElementDetected) {\n          // we also need to ensure that the element is or will be apart of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n        }\n\n        parentElement = parentElement.parent();\n      }\n\n      var allowAnimation = !parentAnimationDetected || animateChildren;\n      return allowAnimation && rootElementDetected && bodyElementDetected;\n    }\n\n    function markElementAnimationState(element, state, details) {\n      details = details || {};\n      details.state = state;\n\n      var node = getDomNode(element);\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.put(node, newValue);\n    }\n  }];\n}];\n\nvar $$rAFMutexFactory = ['$$rAF', function($$rAF) {\n  return function() {\n    var passed = false;\n    $$rAF(function() {\n      passed = true;\n    });\n    return function(fn) {\n      passed ? fn() : $$rAF(fn);\n    };\n  };\n}];\n\nvar $$AnimateRunnerFactory = ['$q', '$$rAFMutex', function($q, $$rAFMutex) {\n  var INITIAL_STATE = 0;\n  var DONE_PENDING_STATE = 1;\n  var DONE_COMPLETE_STATE = 2;\n\n  AnimateRunner.chain = function(chain, callback) {\n    var index = 0;\n\n    next();\n    function next() {\n      if (index === chain.length) {\n        callback(true);\n        return;\n      }\n\n      chain[index](function(response) {\n        if (response === false) {\n          callback(false);\n          return;\n        }\n        index++;\n        next();\n      });\n    }\n  };\n\n  AnimateRunner.all = function(runners, callback) {\n    var count = 0;\n    var status = true;\n    forEach(runners, function(runner) {\n      runner.done(onProgress);\n    });\n\n    function onProgress(response) {\n      status = status && response;\n      if (++count === runners.length) {\n        callback(status);\n      }\n    }\n  };\n\n  function AnimateRunner(host) {\n    this.setHost(host);\n\n    this._doneCallbacks = [];\n    this._runInAnimationFrame = $$rAFMutex();\n    this._state = 0;\n  }\n\n  AnimateRunner.prototype = {\n    setHost: function(host) {\n      this.host = host || {};\n    },\n\n    done: function(fn) {\n      if (this._state === DONE_COMPLETE_STATE) {\n        fn();\n      } else {\n        this._doneCallbacks.push(fn);\n      }\n    },\n\n    progress: noop,\n\n    getPromise: function() {\n      if (!this.promise) {\n        var self = this;\n        this.promise = $q(function(resolve, reject) {\n          self.done(function(status) {\n            status === false ? reject() : resolve();\n          });\n        });\n      }\n      return this.promise;\n    },\n\n    then: function(resolveHandler, rejectHandler) {\n      return this.getPromise().then(resolveHandler, rejectHandler);\n    },\n\n    'catch': function(handler) {\n      return this.getPromise()['catch'](handler);\n    },\n\n    'finally': function(handler) {\n      return this.getPromise()['finally'](handler);\n    },\n\n    pause: function() {\n      if (this.host.pause) {\n        this.host.pause();\n      }\n    },\n\n    resume: function() {\n      if (this.host.resume) {\n        this.host.resume();\n      }\n    },\n\n    end: function() {\n      if (this.host.end) {\n        this.host.end();\n      }\n      this._resolve(true);\n    },\n\n    cancel: function() {\n      if (this.host.cancel) {\n        this.host.cancel();\n      }\n      this._resolve(false);\n    },\n\n    complete: function(response) {\n      var self = this;\n      if (self._state === INITIAL_STATE) {\n        self._state = DONE_PENDING_STATE;\n        self._runInAnimationFrame(function() {\n          self._resolve(response);\n        });\n      }\n    },\n\n    _resolve: function(response) {\n      if (this._state !== DONE_COMPLETE_STATE) {\n        forEach(this._doneCallbacks, function(fn) {\n          fn(response);\n        });\n        this._doneCallbacks.length = 0;\n        this._state = DONE_COMPLETE_STATE;\n      }\n    }\n  };\n\n  return AnimateRunner;\n}];\n\nvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$rAFScheduler',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var totalPendingClassBasedAnimations = 0;\n    var totalActiveClassBasedAnimations = 0;\n    var classBasedAnimationsQueue = [];\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver's end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += ' ' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      var classBasedIndex;\n      if (!isStructural) {\n        classBasedIndex = totalPendingClassBasedAnimations;\n        totalPendingClassBasedAnimations += 1;\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        classBasedIndex: classBasedIndex,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on('$destroy', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        totalActiveClassBasedAnimations = totalPendingClassBasedAnimations;\n        totalPendingClassBasedAnimations = 0;\n        classBasedAnimationsQueue.length = 0;\n\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can't animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        forEach(groupAnimations(animations), function(animationEntry) {\n          if (animationEntry.structural) {\n            triggerAnimationStart();\n          } else {\n            classBasedAnimationsQueue.push({\n              node: getDomNode(animationEntry.element),\n              fn: triggerAnimationStart\n            });\n\n            if (animationEntry.classBasedIndex === totalActiveClassBasedAnimations - 1) {\n              // we need to sort each of the animations in order of parent to child\n              // relationships. This ensures that the child classes are applied at the\n              // right time.\n              classBasedAnimationsQueue = classBasedAnimationsQueue.sort(function(a,b) {\n                return b.node.contains(a.node);\n              }).map(function(entry) {\n                return entry.fn;\n              });\n\n              $$rAFScheduler(classBasedAnimationsQueue);\n            }\n          }\n\n          function triggerAnimationStart() {\n            // it's important that we apply the `ng-animate` CSS class and the\n            // temporary classes before we do any driver invoking since these\n            // CSS classes may be required for proper CSS detection.\n            animationEntry.beforeStart();\n\n            var startAnimationFn, closeFn = animationEntry.close;\n\n            // in the event that the element was removed before the digest runs or\n            // during the RAF sequencing then we should not trigger the animation.\n            var targetElement = animationEntry.anchors\n                ? (animationEntry.from.element || animationEntry.to.element)\n                : animationEntry.element;\n\n            if (getRunner(targetElement) && getDomNode(targetElement).parentNode) {\n              var operation = invokeFirstDriver(animationEntry);\n              if (operation) {\n                startAnimationFn = operation.start;\n              }\n            }\n\n            if (!startAnimationFn) {\n              closeFn();\n            } else {\n              var animationRunner = startAnimationFn();\n              animationRunner.done(function(status) {\n                closeFn(!status);\n              });\n              updateAnimationRunners(animationEntry, animationRunner);\n            }\n          }\n        });\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? 'to' : 'from';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can't have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effictively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            'out': from.element, 'in': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(' ');\n        b = b.split(' ');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === 'ng-') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(' ');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check\n\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          getRunner(element).setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) { // jshint ignore:line\n        element.off('$destroy', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/* global angularAnimateModule: true,\n\n   $$rAFMutexFactory,\n   $$rAFSchedulerFactory,\n   $$AnimateChildrenDirective,\n   $$AnimateRunnerFactory,\n   $$AnimateQueueProvider,\n   $$AnimationProvider,\n   $AnimateCssProvider,\n   $$AnimateCssDriverProvider,\n   $$AnimateJsProvider,\n   $$AnimateJsDriverProvider,\n*/\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` then the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on a element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=true\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; in case the stagger doesn't work then the duration value\n *    must be set to 0 to avoid an accidental CSS inheritance &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the ainmation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       }).start();\n*        runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       }).start();\n *\n *       runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id:1, title: \"Miss Beulah Roob\" },\n            { id:2, title: \"Trent Morissette\" },\n            { id:3, title: \"Miss Ava Pouros\" },\n            { id:4, title: \"Rod Pouros\" },\n            { id:5, title: \"Abdul Rice\" },\n            { id:6, title: \"Laurie Rutherford Sr.\" },\n            { id:7, title: \"Nakia McLaughlin\" },\n            { id:8, title: \"Jordon Blanda DVM\" },\n            { id:9, title: \"Rhoda Hand\" },\n            { id:10, title: \"Alexandrea Sauer\" }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ### Preventing Collisions With Third Party Libraries\n *\n * Some third-party frameworks place animation duration defaults across many element or className\n * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which\n * is expecting actual animations on these elements and has to wait for their completion.\n *\n * You can prevent this unwanted behavior by using a prefix on all your animation classes:\n *\n * ```css\n * /&#42; prefixed with animate- &#42;/\n * .animate-fade-add.animate-fade-add-active {\n *   transition:1s linear all;\n *   opacity:0;\n * }\n * ```\n *\n * You then configure `$animate` to enforce this prefix:\n *\n * ```js\n * $animateProvider.classNameFilter(/animate-/);\n * ```\n *\n * This also may provide your application with a speed boost since only specific elements containing CSS class prefix\n * will be evaluated for animation when any DOM changes occur in the application.\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate $animate to learn more about animations with `$animate`}.\n */\nangular.module('ngAnimate', [])\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n\n  .factory('$$rAFMutex', $$rAFMutexFactory)\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\n  .factory('$$AnimateRunner', $$AnimateRunnerFactory)\n\n  .provider('$$animateQueue', $$AnimateQueueProvider)\n  .provider('$$animation', $$AnimationProvider)\n\n  .provider('$animateCss', $AnimateCssProvider)\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\n  .provider('$$animateJs', $$AnimateJsProvider)\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n","/**\n * State-based routing for AngularJS\n * @version v0.2.15\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will caues `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\]-]+)|\\{([\\w\\[\\]-]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+(-+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:  surroundPattern = ['?(', ')?']; break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n    type        = $$UMFP.type(regexp || \"string\") || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    var param = this.params[paramName];\n    var paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validate\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  function valToString(val) { return val != null ? val.toString().replace(/\\//g, \"%2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/%2F/g, \"/\") : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    string: {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    int: {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    bool: {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    date: {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    json: {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    any: { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n      return config.type instanceof Type ? config.type : new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {object} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. if handle is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|object} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];\n  function $get(   $location,   $rootScope,   $injector,   $browser) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = extend({}, state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"'' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explictly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explictly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n\n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Re-add the saved hash before we start returning things\n        if (hash) toParams['#'] = hash;\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .value('$stateParams', {})\n  .provider('$state', $StateProvider);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        if (result && options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$viewContentLoading\n         * @eventOf ui.router.state.$view\n         * @eventType broadcast on root scope\n         * @description\n         *\n         * Fired once the view **begins loading**, *before* the DOM is rendered.\n         *\n         * @param {Object} event Event object.\n         * @param {Object} viewConfig The view config properties (template, controller, etc).\n         *\n         * @example\n         *\n         * <pre>\n         * $scope.$on('$viewContentLoading',\n         * function(event, viewConfig){\n         *     // Access to all the view config properties.\n         *     // and one special property 'targetView'\n         *     // viewConfig.targetView\n         * });\n         * </pre>\n         */\n          $rootScope.$broadcast('$viewContentLoading', options);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n * \n * @example\n * A view can be unnamed or named. \n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div> \n * \n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a \n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div> \n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n * \n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * But typically you'll only use the views property if you name your view or have more than one view \n * in the same template. There's not really a compelling reason to name a view if its the only one, \n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre> \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div> \n * <div ui-view=\"data\"></div> \n * </pre>\n * \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = function() {\n      return {\n        enter: function (element, target, cb) { target.after(element); cb(); },\n        leave: function (element, cb) { element.remove(); cb(); }\n      };\n    };\n\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          var promise = $animate.enter(element, null, target, cb);\n          if (promise && promise.then) promise.then(cb);\n        },\n        leave: function(element, cb) {\n          var promise = $animate.leave(element, cb);\n          if (promise && promise.then) promise.then(cb);\n        }\n      };\n    }\n\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics();\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope);\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n        scope.$on('$viewContentLoading', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          if (previousEl) {\n            previousEl.remove();\n            previousEl = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n\n          if (currentEl) {\n            renderer.leave(currentEl, function() {\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n            currentEl = null;\n          }\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, $element, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          var clone = $transclude(newScope, function(clone) {\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description           *\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           */\n          currentScope.$emit('$viewContentLoaded');\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(scope, attrs, $element, $interpolate),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n          }\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, element, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  var inherited = element.inheritedData('$uiView');\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated \n * URL, the directive will automatically generate & update the `href` attribute via \n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking \n * the link will trigger a state transition with optional parameters. \n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be \n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative \n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the \n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the \n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n * \n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n * \n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n * \n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  var allowedOptions = ['location', 'inherit', 'reload', 'absolute'];\n\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref = parseStateRef(attrs.uiSref, $state.current.name);\n      var params = null, url = null, base = stateContext(element) || $state.$current;\n      // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n      var hrefKind = Object.prototype.toString.call(element.prop('href')) === '[object SVGAnimatedString]' ?\n                 'xlink:href' : 'href';\n      var newHref = null, isAnchor = element.prop(\"tagName\").toUpperCase() === \"A\";\n      var isForm = element[0].nodeName === \"FORM\";\n      var attr = isForm ? \"action\" : hrefKind, nav = true;\n\n      var options = { relative: base, inherit: true };\n      var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};\n\n      angular.forEach(allowedOptions, function(option) {\n        if (option in optionsOverride) {\n          options[option] = optionsOverride[option];\n        }\n      });\n\n      var update = function(newVal) {\n        if (newVal) params = angular.copy(newVal);\n        if (!nav) return;\n\n        newHref = $state.href(ref.state, params, options);\n\n        var activeDirective = uiSrefActive[1] || uiSrefActive[0];\n        if (activeDirective) {\n          activeDirective.$$addStateInfo(ref.state, params);\n        }\n        if (newHref === null) {\n          nav = false;\n          return false;\n        }\n        attrs.$set(attr, newHref);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(newVal, oldVal) {\n          if (newVal !== params) update(newVal);\n        }, true);\n        params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (isForm) return;\n\n      element.bind(\"click\", function(e) {\n        var button = e.which || e.button;\n        if ( !(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target')) ) {\n          // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n          var transition = $timeout(function() {\n            $state.go(ref.state, params, options);\n          });\n          e.preventDefault();\n\n          // if the state has no URL, ignore one preventDefault from the <a> directive.\n          var ignorePreventDefaultCount = isAnchor && !newHref ? 1: 0;\n          e.preventDefault = function() {\n            if (ignorePreventDefaultCount-- <= 0)\n              $timeout.cancel(transition);\n          };\n        }\n      });\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {\n      var states = [], activeClass;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        var state = $state.get(newState, stateContext($element));\n\n        states.push({\n          state: state || { name: newState },\n          params: newParams\n        });\n\n        update();\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      // Update route state\n      function update() {\n        if (anyMatch()) {\n          $element.addClass(activeClass);\n        } else {\n          $element.removeClass(activeClass);\n        }\n      }\n\n      function anyMatch() {\n        for (var i = 0; i < states.length; i++) {\n          if (isMatch(states[i].state, states[i].params)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      function isMatch(state, params) {\n        if (typeof $attrs.uiSrefActiveEq !== 'undefined') {\n          return $state.is(state.name, params);\n        } else {\n          return $state.includes(state.name, params);\n        }\n      }\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state) {\n    return $state.is(state);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state) {\n    return $state.includes(state);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);","/**\n * @license AngularJS v1.4.3\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\nvar $resourceMinErr = angular.$$minErr('$resource');\n\n// Helper functions and regex to lookup a dotted path on an object\n// stopping at undefined/null.  The path must be composed of ASCII\n// identifiers (just like $parse)\nvar MEMBER_NAME_REGEX = /^(\\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;\n\nfunction isValidDottedPath(path) {\n  return (path != null && path !== '' && path !== 'hasOwnProperty' &&\n      MEMBER_NAME_REGEX.test('.' + path));\n}\n\nfunction lookupDottedPath(obj, path) {\n  if (!isValidDottedPath(path)) {\n    throw $resourceMinErr('badmember', 'Dotted member path \"@{0}\" is invalid.', path);\n  }\n  var keys = path.split('.');\n  for (var i = 0, ii = keys.length; i < ii && obj !== undefined; i++) {\n    var key = keys[i];\n    obj = (obj !== null) ? obj[key] : undefined;\n  }\n  return obj;\n}\n\n/**\n * Create a shallow copy of an object and clear other fields from the destination\n */\nfunction shallowClearAndCopy(src, dst) {\n  dst = dst || {};\n\n  angular.forEach(dst, function(value, key) {\n    delete dst[key];\n  });\n\n  for (var key in src) {\n    if (src.hasOwnProperty(key) && !(key.charAt(0) === '$' && key.charAt(1) === '$')) {\n      dst[key] = src[key];\n    }\n  }\n\n  return dst;\n}\n\n/**\n * @ngdoc module\n * @name ngResource\n * @description\n *\n * # ngResource\n *\n * The `ngResource` module provides interaction support with RESTful services\n * via the $resource service.\n *\n *\n * <div doc-module-components=\"ngResource\"></div>\n *\n * See {@link ngResource.$resource `$resource`} for usage.\n */\n\n/**\n * @ngdoc service\n * @name $resource\n * @requires $http\n *\n * @description\n * A factory which creates a resource object that lets you interact with\n * [RESTful](http://en.wikipedia.org/wiki/Representational_State_Transfer) server-side data sources.\n *\n * The returned resource object has action methods which provide high-level behaviors without\n * the need to interact with the low level {@link ng.$http $http} service.\n *\n * Requires the {@link ngResource `ngResource`} module to be installed.\n *\n * By default, trailing slashes will be stripped from the calculated URLs,\n * which can pose problems with server backends that do not expect that\n * behavior.  This can be disabled by configuring the `$resourceProvider` like\n * this:\n *\n * ```js\n     app.config(['$resourceProvider', function($resourceProvider) {\n       // Don't strip trailing slashes from calculated URLs\n       $resourceProvider.defaults.stripTrailingSlashes = false;\n     }]);\n * ```\n *\n * @param {string} url A parameterized URL template with parameters prefixed by `:` as in\n *   `/user/:username`. If you are using a URL with a port number (e.g.\n *   `http://example.com:8080/api`), it will be respected.\n *\n *   If you are using a url with a suffix, just add the suffix, like this:\n *   `$resource('http://example.com/resource.json')` or `$resource('http://example.com/:id.json')`\n *   or even `$resource('http://example.com/resource/:resource_id.:format')`\n *   If the parameter before the suffix is empty, :resource_id in this case, then the `/.` will be\n *   collapsed down to a single `.`.  If you need this sequence to appear and not collapse then you\n *   can escape it with `/\\.`.\n *\n * @param {Object=} paramDefaults Default values for `url` parameters. These can be overridden in\n *   `actions` methods. If any of the parameter value is a function, it will be executed every time\n *   when a param value needs to be obtained for a request (unless the param was overridden).\n *\n *   Each key value in the parameter object is first bound to url template if present and then any\n *   excess keys are appended to the url search query after the `?`.\n *\n *   Given a template `/path/:verb` and parameter `{verb:'greet', salutation:'Hello'}` results in\n *   URL `/path/greet?salutation=Hello`.\n *\n *   If the parameter value is prefixed with `@` then the value for that parameter will be extracted\n *   from the corresponding property on the `data` object (provided when calling an action method).  For\n *   example, if the `defaultParam` object is `{someParam: '@someProp'}` then the value of `someParam`\n *   will be `data.someProp`.\n *\n * @param {Object.<Object>=} actions Hash with declaration of custom actions that should extend\n *   the default set of resource actions. The declaration should be created in the format of {@link\n *   ng.$http#usage $http.config}:\n *\n *       {action1: {method:?, params:?, isArray:?, headers:?, ...},\n *        action2: {method:?, params:?, isArray:?, headers:?, ...},\n *        ...}\n *\n *   Where:\n *\n *   - **`action`** – {string} – The name of action. This name becomes the name of the method on\n *     your resource object.\n *   - **`method`** – {string} – Case insensitive HTTP method (e.g. `GET`, `POST`, `PUT`,\n *     `DELETE`, `JSONP`, etc).\n *   - **`params`** – {Object=} – Optional set of pre-bound parameters for this action. If any of\n *     the parameter value is a function, it will be executed every time when a param value needs to\n *     be obtained for a request (unless the param was overridden).\n *   - **`url`** – {string} – action specific `url` override. The url templating is supported just\n *     like for the resource-level urls.\n *   - **`isArray`** – {boolean=} – If true then the returned object for this action is an array,\n *     see `returns` section.\n *   - **`transformRequest`** –\n *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n *     transform function or an array of such functions. The transform function takes the http\n *     request body and headers and returns its transformed (typically serialized) version.\n *     By default, transformRequest will contain one function that checks if the request data is\n *     an object and serializes to using `angular.toJson`. To prevent this behavior, set\n *     `transformRequest` to an empty array: `transformRequest: []`\n *   - **`transformResponse`** –\n *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n *     transform function or an array of such functions. The transform function takes the http\n *     response body and headers and returns its transformed (typically deserialized) version.\n *     By default, transformResponse will contain one function that checks if the response looks like\n *     a JSON string and deserializes it using `angular.fromJson`. To prevent this behavior, set\n *     `transformResponse` to an empty array: `transformResponse: []`\n *   - **`cache`** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the\n *     GET request, otherwise if a cache instance built with\n *     {@link ng.$cacheFactory $cacheFactory}, this cache will be used for\n *     caching.\n *   - **`timeout`** – `{number|Promise}` – timeout in milliseconds, or {@link ng.$q promise} that\n *     should abort the request when resolved.\n *   - **`withCredentials`** - `{boolean}` - whether to set the `withCredentials` flag on the\n *     XHR object. See\n *     [requests with credentials](https://developer.mozilla.org/en/http_access_control#section_5)\n *     for more information.\n *   - **`responseType`** - `{string}` - see\n *     [requestType](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType).\n *   - **`interceptor`** - `{Object=}` - The interceptor object has two optional methods -\n *     `response` and `responseError`. Both `response` and `responseError` interceptors get called\n *     with `http response` object. See {@link ng.$http $http interceptors}.\n *\n * @param {Object} options Hash with custom settings that should extend the\n *   default `$resourceProvider` behavior.  The only supported option is\n *\n *   Where:\n *\n *   - **`stripTrailingSlashes`** – {boolean} – If true then the trailing\n *   slashes from any calculated URL will be stripped. (Defaults to true.)\n *\n * @returns {Object} A resource \"class\" object with methods for the default set of resource actions\n *   optionally extended with custom `actions`. The default set contains these actions:\n *   ```js\n *   { 'get':    {method:'GET'},\n *     'save':   {method:'POST'},\n *     'query':  {method:'GET', isArray:true},\n *     'remove': {method:'DELETE'},\n *     'delete': {method:'DELETE'} };\n *   ```\n *\n *   Calling these methods invoke an {@link ng.$http} with the specified http method,\n *   destination and parameters. When the data is returned from the server then the object is an\n *   instance of the resource class. The actions `save`, `remove` and `delete` are available on it\n *   as  methods with the `$` prefix. This allows you to easily perform CRUD operations (create,\n *   read, update, delete) on server-side data like this:\n *   ```js\n *   var User = $resource('/user/:userId', {userId:'@id'});\n *   var user = User.get({userId:123}, function() {\n *     user.abc = true;\n *     user.$save();\n *   });\n *   ```\n *\n *   It is important to realize that invoking a $resource object method immediately returns an\n *   empty reference (object or array depending on `isArray`). Once the data is returned from the\n *   server the existing reference is populated with the actual data. This is a useful trick since\n *   usually the resource is assigned to a model which is then rendered by the view. Having an empty\n *   object results in no rendering, once the data arrives from the server then the object is\n *   populated with the data and the view automatically re-renders itself showing the new data. This\n *   means that in most cases one never has to write a callback function for the action methods.\n *\n *   The action methods on the class object or instance object can be invoked with the following\n *   parameters:\n *\n *   - HTTP GET \"class\" actions: `Resource.action([parameters], [success], [error])`\n *   - non-GET \"class\" actions: `Resource.action([parameters], postData, [success], [error])`\n *   - non-GET instance actions:  `instance.$action([parameters], [success], [error])`\n *\n *\n *   Success callback is called with (value, responseHeaders) arguments, where the value is\n *   the populated resource instance or collection object. The error callback is called\n *   with (httpResponse) argument.\n *\n *   Class actions return empty instance (with additional properties below).\n *   Instance actions return promise of the action.\n *\n *   The Resource instances and collection have these additional properties:\n *\n *   - `$promise`: the {@link ng.$q promise} of the original server interaction that created this\n *     instance or collection.\n *\n *     On success, the promise is resolved with the same resource instance or collection object,\n *     updated with data from server. This makes it easy to use in\n *     {@link ngRoute.$routeProvider resolve section of $routeProvider.when()} to defer view\n *     rendering until the resource(s) are loaded.\n *\n *     On failure, the promise is resolved with the {@link ng.$http http response} object, without\n *     the `resource` property.\n *\n *     If an interceptor object was provided, the promise will instead be resolved with the value\n *     returned by the interceptor.\n *\n *   - `$resolved`: `true` after first server interaction is completed (either with success or\n *      rejection), `false` before that. Knowing if the Resource has been resolved is useful in\n *      data-binding.\n *\n * @example\n *\n * # Credit card resource\n *\n * ```js\n     // Define CreditCard class\n     var CreditCard = $resource('/user/:userId/card/:cardId',\n      {userId:123, cardId:'@id'}, {\n       charge: {method:'POST', params:{charge:true}}\n      });\n\n     // We can retrieve a collection from the server\n     var cards = CreditCard.query(function() {\n       // GET: /user/123/card\n       // server returns: [ {id:456, number:'1234', name:'Smith'} ];\n\n       var card = cards[0];\n       // each item is an instance of CreditCard\n       expect(card instanceof CreditCard).toEqual(true);\n       card.name = \"J. Smith\";\n       // non GET methods are mapped onto the instances\n       card.$save();\n       // POST: /user/123/card/456 {id:456, number:'1234', name:'J. Smith'}\n       // server returns: {id:456, number:'1234', name: 'J. Smith'};\n\n       // our custom method is mapped as well.\n       card.$charge({amount:9.99});\n       // POST: /user/123/card/456?amount=9.99&charge=true {id:456, number:'1234', name:'J. Smith'}\n     });\n\n     // we can create an instance as well\n     var newCard = new CreditCard({number:'0123'});\n     newCard.name = \"Mike Smith\";\n     newCard.$save();\n     // POST: /user/123/card {number:'0123', name:'Mike Smith'}\n     // server returns: {id:789, number:'0123', name: 'Mike Smith'};\n     expect(newCard.id).toEqual(789);\n * ```\n *\n * The object returned from this function execution is a resource \"class\" which has \"static\" method\n * for each action in the definition.\n *\n * Calling these methods invoke `$http` on the `url` template with the given `method`, `params` and\n * `headers`.\n * When the data is returned from the server then the object is an instance of the resource type and\n * all of the non-GET methods are available with `$` prefix. This allows you to easily support CRUD\n * operations (create, read, update, delete) on server-side data.\n\n   ```js\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123}, function(user) {\n       user.abc = true;\n       user.$save();\n     });\n   ```\n *\n * It's worth noting that the success callback for `get`, `query` and other methods gets passed\n * in the response that came from the server as well as $http header getter function, so one\n * could rewrite the above example and get access to http headers as:\n *\n   ```js\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123}, function(u, getResponseHeaders){\n       u.abc = true;\n       u.$save(function(u, putResponseHeaders) {\n         //u => saved user object\n         //putResponseHeaders => $http header getter\n       });\n     });\n   ```\n *\n * You can also access the raw `$http` promise via the `$promise` property on the object returned\n *\n   ```\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123})\n         .$promise.then(function(user) {\n           $scope.user = user;\n         });\n   ```\n\n * # Creating a custom 'PUT' request\n * In this example we create a custom method on our resource to make a PUT request\n * ```js\n *    var app = angular.module('app', ['ngResource', 'ngRoute']);\n *\n *    // Some APIs expect a PUT request in the format URL/object/ID\n *    // Here we are creating an 'update' method\n *    app.factory('Notes', ['$resource', function($resource) {\n *    return $resource('/notes/:id', null,\n *        {\n *            'update': { method:'PUT' }\n *        });\n *    }]);\n *\n *    // In our controller we get the ID from the URL using ngRoute and $routeParams\n *    // We pass in $routeParams and our Notes factory along with $scope\n *    app.controller('NotesCtrl', ['$scope', '$routeParams', 'Notes',\n                                      function($scope, $routeParams, Notes) {\n *    // First get a note object from the factory\n *    var note = Notes.get({ id:$routeParams.id });\n *    $id = note.id;\n *\n *    // Now call update passing in the ID first then the object you are updating\n *    Notes.update({ id:$id }, note);\n *\n *    // This will PUT /notes/ID with the note object in the request payload\n *    }]);\n * ```\n */\nangular.module('ngResource', ['ng']).\n  provider('$resource', function() {\n    var provider = this;\n\n    this.defaults = {\n      // Strip slashes by default\n      stripTrailingSlashes: true,\n\n      // Default actions configuration\n      actions: {\n        'get': {method: 'GET'},\n        'save': {method: 'POST'},\n        'query': {method: 'GET', isArray: true},\n        'remove': {method: 'DELETE'},\n        'delete': {method: 'DELETE'}\n      }\n    };\n\n    this.$get = ['$http', '$q', function($http, $q) {\n\n      var noop = angular.noop,\n        forEach = angular.forEach,\n        extend = angular.extend,\n        copy = angular.copy,\n        isFunction = angular.isFunction;\n\n      /**\n       * We need our custom method because encodeURIComponent is too aggressive and doesn't follow\n       * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set\n       * (pchar) allowed in path segments:\n       *    segment       = *pchar\n       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n       */\n      function encodeUriSegment(val) {\n        return encodeUriQuery(val, true).\n          replace(/%26/gi, '&').\n          replace(/%3D/gi, '=').\n          replace(/%2B/gi, '+');\n      }\n\n\n      /**\n       * This method is intended for encoding *key* or *value* parts of query component. We need a\n       * custom method because encodeURIComponent is too aggressive and encodes stuff that doesn't\n       * have to be encoded per http://tools.ietf.org/html/rfc3986:\n       *    query       = *( pchar / \"/\" / \"?\" )\n       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n       */\n      function encodeUriQuery(val, pctEncodeSpaces) {\n        return encodeURIComponent(val).\n          replace(/%40/gi, '@').\n          replace(/%3A/gi, ':').\n          replace(/%24/g, '$').\n          replace(/%2C/gi, ',').\n          replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));\n      }\n\n      function Route(template, defaults) {\n        this.template = template;\n        this.defaults = extend({}, provider.defaults, defaults);\n        this.urlParams = {};\n      }\n\n      Route.prototype = {\n        setUrlParams: function(config, params, actionUrl) {\n          var self = this,\n            url = actionUrl || self.template,\n            val,\n            encodedVal;\n\n          var urlParams = self.urlParams = {};\n          forEach(url.split(/\\W/), function(param) {\n            if (param === 'hasOwnProperty') {\n              throw $resourceMinErr('badname', \"hasOwnProperty is not a valid parameter name.\");\n            }\n            if (!(new RegExp(\"^\\\\d+$\").test(param)) && param &&\n              (new RegExp(\"(^|[^\\\\\\\\]):\" + param + \"(\\\\W|$)\").test(url))) {\n              urlParams[param] = true;\n            }\n          });\n          url = url.replace(/\\\\:/g, ':');\n\n          params = params || {};\n          forEach(self.urlParams, function(_, urlParam) {\n            val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];\n            if (angular.isDefined(val) && val !== null) {\n              encodedVal = encodeUriSegment(val);\n              url = url.replace(new RegExp(\":\" + urlParam + \"(\\\\W|$)\", \"g\"), function(match, p1) {\n                return encodedVal + p1;\n              });\n            } else {\n              url = url.replace(new RegExp(\"(\\/?):\" + urlParam + \"(\\\\W|$)\", \"g\"), function(match,\n                  leadingSlashes, tail) {\n                if (tail.charAt(0) == '/') {\n                  return tail;\n                } else {\n                  return leadingSlashes + tail;\n                }\n              });\n            }\n          });\n\n          // strip trailing slashes and set the url (unless this behavior is specifically disabled)\n          if (self.defaults.stripTrailingSlashes) {\n            url = url.replace(/\\/+$/, '') || '/';\n          }\n\n          // then replace collapse `/.` if found in the last URL path segment before the query\n          // E.g. `http://url.com/id./format?q=x` becomes `http://url.com/id.format?q=x`\n          url = url.replace(/\\/\\.(?=\\w+($|\\?))/, '.');\n          // replace escaped `/\\.` with `/.`\n          config.url = url.replace(/\\/\\\\\\./, '/.');\n\n\n          // set params - delegate param encoding to $http\n          forEach(params, function(value, key) {\n            if (!self.urlParams[key]) {\n              config.params = config.params || {};\n              config.params[key] = value;\n            }\n          });\n        }\n      };\n\n\n      function resourceFactory(url, paramDefaults, actions, options) {\n        var route = new Route(url, options);\n\n        actions = extend({}, provider.defaults.actions, actions);\n\n        function extractParams(data, actionParams) {\n          var ids = {};\n          actionParams = extend({}, paramDefaults, actionParams);\n          forEach(actionParams, function(value, key) {\n            if (isFunction(value)) { value = value(); }\n            ids[key] = value && value.charAt && value.charAt(0) == '@' ?\n              lookupDottedPath(data, value.substr(1)) : value;\n          });\n          return ids;\n        }\n\n        function defaultResponseInterceptor(response) {\n          return response.resource;\n        }\n\n        function Resource(value) {\n          shallowClearAndCopy(value || {}, this);\n        }\n\n        Resource.prototype.toJSON = function() {\n          var data = extend({}, this);\n          delete data.$promise;\n          delete data.$resolved;\n          return data;\n        };\n\n        forEach(actions, function(action, name) {\n          var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);\n\n          Resource[name] = function(a1, a2, a3, a4) {\n            var params = {}, data, success, error;\n\n            /* jshint -W086 */ /* (purposefully fall through case statements) */\n            switch (arguments.length) {\n              case 4:\n                error = a4;\n                success = a3;\n              //fallthrough\n              case 3:\n              case 2:\n                if (isFunction(a2)) {\n                  if (isFunction(a1)) {\n                    success = a1;\n                    error = a2;\n                    break;\n                  }\n\n                  success = a2;\n                  error = a3;\n                  //fallthrough\n                } else {\n                  params = a1;\n                  data = a2;\n                  success = a3;\n                  break;\n                }\n              case 1:\n                if (isFunction(a1)) success = a1;\n                else if (hasBody) data = a1;\n                else params = a1;\n                break;\n              case 0: break;\n              default:\n                throw $resourceMinErr('badargs',\n                  \"Expected up to 4 arguments [params, data, success, error], got {0} arguments\",\n                  arguments.length);\n            }\n            /* jshint +W086 */ /* (purposefully fall through case statements) */\n\n            var isInstanceCall = this instanceof Resource;\n            var value = isInstanceCall ? data : (action.isArray ? [] : new Resource(data));\n            var httpConfig = {};\n            var responseInterceptor = action.interceptor && action.interceptor.response ||\n              defaultResponseInterceptor;\n            var responseErrorInterceptor = action.interceptor && action.interceptor.responseError ||\n              undefined;\n\n            forEach(action, function(value, key) {\n              if (key != 'params' && key != 'isArray' && key != 'interceptor') {\n                httpConfig[key] = copy(value);\n              }\n            });\n\n            if (hasBody) httpConfig.data = data;\n            route.setUrlParams(httpConfig,\n              extend({}, extractParams(data, action.params || {}), params),\n              action.url);\n\n            var promise = $http(httpConfig).then(function(response) {\n              var data = response.data,\n                promise = value.$promise;\n\n              if (data) {\n                // Need to convert action.isArray to boolean in case it is undefined\n                // jshint -W018\n                if (angular.isArray(data) !== (!!action.isArray)) {\n                  throw $resourceMinErr('badcfg',\n                      'Error in resource configuration for action `{0}`. Expected response to ' +\n                      'contain an {1} but got an {2} (Request: {3} {4})', name, action.isArray ? 'array' : 'object',\n                    angular.isArray(data) ? 'array' : 'object', httpConfig.method, httpConfig.url);\n                }\n                // jshint +W018\n                if (action.isArray) {\n                  value.length = 0;\n                  forEach(data, function(item) {\n                    if (typeof item === \"object\") {\n                      value.push(new Resource(item));\n                    } else {\n                      // Valid JSON values may be string literals, and these should not be converted\n                      // into objects. These items will not have access to the Resource prototype\n                      // methods, but unfortunately there\n                      value.push(item);\n                    }\n                  });\n                } else {\n                  shallowClearAndCopy(data, value);\n                  value.$promise = promise;\n                }\n              }\n\n              value.$resolved = true;\n\n              response.resource = value;\n\n              return response;\n            }, function(response) {\n              value.$resolved = true;\n\n              (error || noop)(response);\n\n              return $q.reject(response);\n            });\n\n            promise = promise.then(\n              function(response) {\n                var value = responseInterceptor(response);\n                (success || noop)(value, response.headers);\n                return value;\n              },\n              responseErrorInterceptor);\n\n            if (!isInstanceCall) {\n              // we are creating instance / collection\n              // - set the initial promise\n              // - return the instance / collection\n              value.$promise = promise;\n              value.$resolved = false;\n\n              return value;\n            }\n\n            // instance call\n            return promise;\n          };\n\n\n          Resource.prototype['$' + name] = function(params, success, error) {\n            if (isFunction(params)) {\n              error = success; success = params; params = {};\n            }\n            var result = Resource[name].call(this, params, this, success, error);\n            return result.$promise || result;\n          };\n        });\n\n        Resource.bind = function(additionalParamDefaults) {\n          return resourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);\n        };\n\n        return Resource;\n      }\n\n      return resourceFactory;\n    }];\n  });\n\n\n})(window, window.angular);\n","(function() {\n\n\n// Create all modules and define dependencies to make sure they exist\n// and are loaded in the correct order to satisfy dependency injection\n// before all nested files are concatenated by Grunt\n\n// Modules\nangular.module('angular-jwt',\n    [\n        'angular-jwt.interceptor',\n        'angular-jwt.jwt'\n    ]);\n\n angular.module('angular-jwt.interceptor', [])\n  .provider('jwtInterceptor', function() {\n\n    this.urlParam = null;\n    this.authHeader = 'Authorization';\n    this.authPrefix = 'Bearer ';\n    this.tokenGetter = function() {\n      return null;\n    }\n\n    var config = this;\n\n    this.$get = [\"$q\", \"$injector\", \"$rootScope\", function ($q, $injector, $rootScope) {\n      return {\n        request: function (request) {\n          if (request.skipAuthorization) {\n            return request;\n          }\n\n          if (config.urlParam) {\n            request.params = request.params || {};\n            // Already has the token in the url itself\n            if (request.params[config.urlParam]) {\n              return request;\n            }\n          } else {\n            request.headers = request.headers || {};\n            // Already has an Authorization header\n            if (request.headers[config.authHeader]) {\n              return request;\n            }\n          }\n\n          var tokenPromise = $q.when($injector.invoke(config.tokenGetter, this, {\n            config: request\n          }));\n\n          return tokenPromise.then(function(token) {\n            if (token) {\n              if (config.urlParam) {\n                request.params[config.urlParam] = token;\n              } else {\n                request.headers[config.authHeader] = config.authPrefix + token;\n              }\n            }\n            return request;\n          });\n        },\n        responseError: function (response) {\n          // handle the case where the user is not authenticated\n          if (response.status === 401) {\n            $rootScope.$broadcast('unauthenticated', response);\n          }\n          return $q.reject(response);\n        }\n      };\n    }];\n  });\n\n angular.module('angular-jwt.jwt', [])\n  .service('jwtHelper', function() {\n\n    this.urlBase64Decode = function(str) {\n      var output = str.replace(/-/g, '+').replace(/_/g, '/');\n      switch (output.length % 4) {\n        case 0: { break; }\n        case 2: { output += '=='; break; }\n        case 3: { output += '='; break; }\n        default: {\n          throw 'Illegal base64url string!';\n        }\n      }\n      return decodeURIComponent(escape(window.atob(output))); //polifyll https://github.com/davidchambers/Base64.js\n    }\n\n\n    this.decodeToken = function(token) {\n      var parts = token.split('.');\n\n      if (parts.length !== 3) {\n        throw new Error('JWT must have 3 parts');\n      }\n\n      var decoded = this.urlBase64Decode(parts[1]);\n      if (!decoded) {\n        throw new Error('Cannot decode the token');\n      }\n\n      return JSON.parse(decoded);\n    }\n\n    this.getTokenExpirationDate = function(token) {\n      var decoded;\n      decoded = this.decodeToken(token);\n\n      if(typeof decoded.exp === \"undefined\") {\n        return null;\n      }\n\n      var d = new Date(0); // The 0 here is the key, which sets the date to the epoch\n      d.setUTCSeconds(decoded.exp);\n\n      return d;\n    };\n\n    this.isTokenExpired = function(token, offsetSeconds) {\n      var d = this.getTokenExpirationDate(token);\n      offsetSeconds = offsetSeconds || 0;\n      if (d === null) {\n        return false;\n      }\n\n      // Token expired?\n      return !(d.valueOf() > (new Date().valueOf() + (offsetSeconds * 1000)));\n    };\n  });\n\n}());","/**\n * angular-slugify -- provides slugification for AngularJS\n *\n * Copyright © 2013 Paul Smith <paulsmith@pobox.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the “Software”), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n(function() {\n    \"use strict\";\n\n    var mod = angular.module(\"slugifier\", []);\n\n    // Unicode (non-control) characters in the Latin-1 Supplement and Latin\n    // Extended-A blocks, transliterated into ASCII characters.\n    var charmap = {\n        ' ': \" \",\n        '¡': \"!\",\n        '¢': \"c\",\n        '£': \"lb\",\n        '¥': \"yen\",\n        '¦': \"|\",\n        '§': \"SS\",\n        '¨': \"\\\"\",\n        '©': \"(c)\",\n        'ª': \"a\",\n        '«': \"<<\",\n        '¬': \"not\",\n        '­': \"-\",\n        '®': \"(R)\",\n        '°': \"^0\",\n        '±': \"+/-\",\n        '²': \"^2\",\n        '³': \"^3\",\n        '´': \"'\",\n        'µ': \"u\",\n        '¶': \"P\",\n        '·': \".\",\n        '¸': \",\",\n        '¹': \"^1\",\n        'º': \"o\",\n        '»': \">>\",\n        '¼': \" 1/4 \",\n        '½': \" 1/2 \",\n        '¾': \" 3/4 \",\n        '¿': \"?\",\n        'À': \"`A\",\n        'Á': \"'A\",\n        'Â': \"^A\",\n        'Ã': \"~A\",\n        'Ä': '\"A',\n        'Å': \"A\",\n        'Æ': \"AE\",\n        'Ç': \"C\",\n        'È': \"`E\",\n        'É': \"'E\",\n        'Ê': \"^E\",\n        'Ë': '\"E',\n        'Ì': \"`I\",\n        'Í': \"'I\",\n        'Î': \"^I\",\n        'Ï': '\"I',\n        'Ð': \"D\",\n        'Ñ': \"~N\",\n        'Ò': \"`O\",\n        'Ó': \"'O\",\n        'Ô': \"^O\",\n        'Õ': \"~O\",\n        'Ö': '\"O',\n        '×': \"x\",\n        'Ø': \"O\",\n        'Ù': \"`U\",\n        'Ú': \"'U\",\n        'Û': \"^U\",\n        'Ü': '\"U',\n        'Ý': \"'Y\",\n        'Þ': \"Th\",\n        'ß': \"ss\",\n        'à': \"`a\",\n        'á': \"'a\",\n        'â': \"^a\",\n        'ã': \"~a\",\n        'ä': '\"a',\n        'å': \"a\",\n        'æ': \"ae\",\n        'ç': \"c\",\n        'è': \"`e\",\n        'é': \"'e\",\n        'ê': \"^e\",\n        'ë': '\"e',\n        'ì': \"`i\",\n        'í': \"'i\",\n        'î': \"^i\",\n        'ï': '\"i',\n        'ð': \"d\",\n        'ñ': \"~n\",\n        'ò': \"`o\",\n        'ó': \"'o\",\n        'ô': \"^o\",\n        'õ': \"~o\",\n        'ö': '\"o',\n        '÷': \":\",\n        'ø': \"o\",\n        'ù': \"`u\",\n        'ú': \"'u\",\n        'û': \"^u\",\n        'ü': '\"u',\n        'ý': \"'y\",\n        'þ': \"th\",\n        'ÿ': '\"y',\n        'Ā': \"A\",\n        'ā': \"a\",\n        'Ă': \"A\",\n        'ă': \"a\",\n        'Ą': \"A\",\n        'ą': \"a\",\n        'Ć': \"'C\",\n        'ć': \"'c\",\n        'Ĉ': \"^C\",\n        'ĉ': \"^c\",\n        'Ċ': \"C\",\n        'ċ': \"c\",\n        'Č': \"C\",\n        'č': \"c\",\n        'Ď': \"D\",\n        'ď': \"d\",\n        'Đ': \"D\",\n        'đ': \"d\",\n        'Ē': \"E\",\n        'ē': \"e\",\n        'Ĕ': \"E\",\n        'ĕ': \"e\",\n        'Ė': \"E\",\n        'ė': \"e\",\n        'Ę': \"E\",\n        'ę': \"e\",\n        'Ě': \"E\",\n        'ě': \"e\",\n        'Ĝ': \"^G\",\n        'ĝ': \"^g\",\n        'Ğ': \"G\",\n        'ğ': \"g\",\n        'Ġ': \"G\",\n        'ġ': \"g\",\n        'Ģ': \"G\",\n        'ģ': \"g\",\n        'Ĥ': \"^H\",\n        'ĥ': \"^h\",\n        'Ħ': \"H\",\n        'ħ': \"h\",\n        'Ĩ': \"~I\",\n        'ĩ': \"~i\",\n        'Ī': \"I\",\n        'ī': \"i\",\n        'Ĭ': \"I\",\n        'ĭ': \"i\",\n        'Į': \"I\",\n        'į': \"i\",\n        'İ': \"I\",\n        'ı': \"i\",\n        'Ĳ': \"IJ\",\n        'ĳ': \"ij\",\n        'Ĵ': \"^J\",\n        'ĵ': \"^j\",\n        'Ķ': \"K\",\n        'ķ': \"k\",\n        'Ĺ': \"L\",\n        'ĺ': \"l\",\n        'Ļ': \"L\",\n        'ļ': \"l\",\n        'Ľ': \"L\",\n        'ľ': \"l\",\n        'Ŀ': \"L\",\n        'ŀ': \"l\",\n        'Ł': \"L\",\n        'ł': \"l\",\n        'Ń': \"'N\",\n        'ń': \"'n\",\n        'Ņ': \"N\",\n        'ņ': \"n\",\n        'Ň': \"N\",\n        'ň': \"n\",\n        'ŉ': \"'n\",\n        'Ō': \"O\",\n        'ō': \"o\",\n        'Ŏ': \"O\",\n        'ŏ': \"o\",\n        'Ő': '\"O',\n        'ő': '\"o',\n        'Œ': \"OE\",\n        'œ': \"oe\",\n        'Ŕ': \"'R\",\n        'ŕ': \"'r\",\n        'Ŗ': \"R\",\n        'ŗ': \"r\",\n        'Ř': \"R\",\n        'ř': \"r\",\n        'Ś': \"'S\",\n        'ś': \"'s\",\n        'Ŝ': \"^S\",\n        'ŝ': \"^s\",\n        'Ş': \"S\",\n        'ş': \"s\",\n        'Š': \"S\",\n        'š': \"s\",\n        'Ţ': \"T\",\n        'ţ': \"t\",\n        'Ť': \"T\",\n        'ť': \"t\",\n        'Ŧ': \"T\",\n        'ŧ': \"t\",\n        'Ũ': \"~U\",\n        'ũ': \"~u\",\n        'Ū': \"U\",\n        'ū': \"u\",\n        'Ŭ': \"U\",\n        'ŭ': \"u\",\n        'Ů': \"U\",\n        'ů': \"u\",\n        'Ű': '\"U',\n        'ű': '\"u',\n        'Ų': \"U\",\n        'ų': \"u\",\n        'Ŵ': \"^W\",\n        'ŵ': \"^w\",\n        'Ŷ': \"^Y\",\n        'ŷ': \"^y\",\n        'Ÿ': '\"Y',\n        'Ź': \"'Z\",\n        'ź': \"'z\",\n        'Ż': \"Z\",\n        'ż': \"z\",\n        'Ž': \"Z\",\n        'ž': \"z\",\n        'ſ': \"s\"\n    };\n\n    function _slugify(s) {\n        if (!s) return \"\";\n        var ascii = [];\n        var ch, cp;\n        for (var i = 0; i < s.length; i++) {\n            if ((cp = s.charCodeAt(i)) < 0x180) {\n                ch = String.fromCharCode(cp);\n                ascii.push(charmap[ch] || ch);\n            }\n        }\n        s = ascii.join(\"\");\n        s = s.replace(/[^\\w\\s-]/g, \"\").trim().toLowerCase();\n        return s.replace(/[-\\s]+/g, \"-\");\n    }\n\n    mod.factory(\"Slug\", function() {\n        return {\n            slugify: _slugify\n        };\n    });\n\n    mod.directive(\"slug\", [\"Slug\", function(Slug) {\n        return {\n            restrict: \"E\",\n            scope: {\n                to: \"=\",\n            },\n            transclude: true,\n            replace: true,\n            template: \"<div ng-transclude></div>\",\n            link: function(scope, elem, attrs) {\n                if (!attrs.from) {\n                    throw \"must set attribute 'from'\";\n                }\n                scope.$parent.$watch(attrs.from, function(val) {\n                    scope.to = Slug.slugify(val);\n                });\n            }\n        };\n    }]);\n\n    mod.filter(\"slugify\", [\"Slug\", function(Slug) {\n        return function(input) {\n            return Slug.slugify(input);\n        };\n    }]);\n})();\n","//\n// Copyright Kamil Pękala http://github.com/kamilkp\n// angular-sortable-view v0.0.13 2015/01/13\n//\n\n;(function(window, angular){\n\t'use strict';\n\t/* jshint eqnull:true */\n\t/* jshint -W041 */\n\t/* jshint -W030 */\n\n\tvar module = angular.module('angular-sortable-view', []);\n\tmodule.directive('svRoot', [function(){\n\t\tfunction shouldBeAfter(elem, pointer, isGrid){\n\t\t\treturn isGrid ? elem.x - pointer.x < 0 : elem.y - pointer.y < 0;\n\t\t}\n\t\tfunction getSortableElements(key){\n\t\t\treturn ROOTS_MAP[key];\n\t\t}\n\t\tfunction removeSortableElements(key){\n\t\t\tdelete ROOTS_MAP[key];\n\t\t}\n\n\t\tvar sortingInProgress;\n\t\tvar ROOTS_MAP = Object.create(null);\n\t\t// window.ROOTS_MAP = ROOTS_MAP; // for debug purposes\n\n\t\treturn {\n\t\t\trestrict: 'A',\n\t\t\tcontroller: ['$scope', '$attrs', '$interpolate', '$parse', function($scope, $attrs, $interpolate, $parse){\n\t\t\t\tvar mapKey = $interpolate($attrs.svRoot)($scope) || $scope.$id;\n\t\t\t\tif(!ROOTS_MAP[mapKey]) ROOTS_MAP[mapKey] = [];\n\n\t\t\t\tvar that         = this;\n\t\t\t\tvar candidates;  // set of possible destinations\n\t\t\t\tvar $placeholder;// placeholder element\n\t\t\t\tvar options;     // sortable options\n\t\t\t\tvar $helper;     // helper element - the one thats being dragged around with the mouse pointer\n\t\t\t\tvar $original;   // original element\n\t\t\t\tvar $target;     // last best candidate\n\t\t\t\tvar isGrid       = false;\n\t\t\t\tvar onSort       = $parse($attrs.svOnSort);\n\n\t\t\t\t// ----- hack due to https://github.com/angular/angular.js/issues/8044\n\t\t\t\t$attrs.svOnStart = $attrs.$$element[0].attributes['sv-on-start'];\n\t\t\t\t$attrs.svOnStart = $attrs.svOnStart && $attrs.svOnStart.value;\n\n\t\t\t\t$attrs.svOnStop = $attrs.$$element[0].attributes['sv-on-stop'];\n\t\t\t\t$attrs.svOnStop = $attrs.svOnStop && $attrs.svOnStop.value;\n\t\t\t\t// -------------------------------------------------------------------\n\n\t\t\t\tvar onStart = $parse($attrs.svOnStart);\n\t\t\t\tvar onStop = $parse($attrs.svOnStop);\n\n\t\t\t\tthis.sortingInProgress = function(){\n\t\t\t\t\treturn sortingInProgress;\n\t\t\t\t};\n\n\t\t\t\tif($attrs.svGrid){ // sv-grid determined explicite\n\t\t\t\t\tisGrid = $attrs.svGrid === \"true\" ? true : $attrs.svGrid === \"false\" ? false : null;\n\t\t\t\t\tif(isGrid === null)\n\t\t\t\t\t\tthrow 'Invalid value of sv-grid attribute';\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// check if at least one of the lists have a grid like layout\n\t\t\t\t\t$scope.$watchCollection(function(){\n\t\t\t\t\t\treturn getSortableElements(mapKey);\n\t\t\t\t\t}, function(collection){\n\t\t\t\t\t\tisGrid = false;\n\t\t\t\t\t\tvar array = collection.filter(function(item){\n\t\t\t\t\t\t\treturn !item.container;\n\t\t\t\t\t\t}).map(function(item){\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tpart: item.getPart().id,\n\t\t\t\t\t\t\t\ty: item.element[0].getBoundingClientRect().top\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvar dict = Object.create(null);\n\t\t\t\t\t\tarray.forEach(function(item){\n\t\t\t\t\t\t\tif(dict[item.part])\n\t\t\t\t\t\t\t\tdict[item.part].push(item.y);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdict[item.part] = [item.y];\n\t\t\t\t\t\t});\n\t\t\t\t\t\tObject.keys(dict).forEach(function(key){\n\t\t\t\t\t\t\tdict[key].sort();\n\t\t\t\t\t\t\tdict[key].forEach(function(item, index){\n\t\t\t\t\t\t\t\tif(index < dict[key].length - 1){\n\t\t\t\t\t\t\t\t\tif(item > 0 && item === dict[key][index + 1]){\n\t\t\t\t\t\t\t\t\t\tisGrid = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis.$moveUpdate = function(opts, mouse, svElement, svOriginal, svPlaceholder, originatingPart, originatingIndex){\n\t\t\t\t\tvar svRect = svElement[0].getBoundingClientRect();\n\t\t\t\t\tif(opts.tolerance === 'element')\n\t\t\t\t\t\tmouse = {\n\t\t\t\t\t\t\tx: ~~(svRect.left + svRect.width/2),\n\t\t\t\t\t\t\ty: ~~(svRect.top + svRect.height/2)\n\t\t\t\t\t\t};\n\n\t\t\t\t\tsortingInProgress = true;\n\t\t\t\t\tcandidates = [];\n\t\t\t\t\tif(!$placeholder){\n\t\t\t\t\t\tif(svPlaceholder){ // custom placeholder\n\t\t\t\t\t\t\t$placeholder = svPlaceholder.clone();\n\t\t\t\t\t\t\t$placeholder.removeClass('ng-hide');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{ // default placeholder\n\t\t\t\t\t\t\t$placeholder = svOriginal.clone();\n\t\t\t\t\t\t\t$placeholder.addClass('sv-visibility-hidden');\n\t\t\t\t\t\t\t$placeholder.addClass('sv-placeholder');\n\t\t\t\t\t\t\t$placeholder.css({\n\t\t\t\t\t\t\t\t'height': svRect.height + 'px',\n\t\t\t\t\t\t\t\t'width': svRect.width + 'px'\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsvOriginal.after($placeholder);\n\t\t\t\t\t\tsvOriginal.addClass('ng-hide');\n\n\t\t\t\t\t\t// cache options, helper and original element reference\n\t\t\t\t\t\t$original = svOriginal;\n\t\t\t\t\t\toptions = opts;\n\t\t\t\t\t\t$helper = svElement;\n\n\t\t\t\t\t\tonStart($scope, {\n\t\t\t\t\t\t\t$helper: $helper,\n\t\t\t\t\t\t\t$part: originatingPart.model(originatingPart.scope),\n\t\t\t\t\t\t\t$index: originatingIndex,\n\t\t\t\t\t\t\t$item: originatingPart.model(originatingPart.scope)[originatingIndex]\n\t\t\t\t\t\t});\n\t\t\t\t\t\t$scope.$root && $scope.$root.$$phase || $scope.$apply();\n\t\t\t\t\t}\n\n\t\t\t\t\t// ----- move the element\n\t\t\t\t\t$helper[0].reposition({\n\t\t\t\t\t\tx: mouse.x + document.body.scrollLeft - mouse.offset.x*svRect.width,\n\t\t\t\t\t\ty: mouse.y + document.body.scrollTop - mouse.offset.y*svRect.height\n\t\t\t\t\t});\n\n\t\t\t\t\t// ----- manage candidates\n\t\t\t\t\tgetSortableElements(mapKey).forEach(function(se, index){\n\t\t\t\t\t\tif(opts.containment != null){\n\t\t\t\t\t\t\t// TODO: optimize this since it could be calculated only once when the moving begins\n\t\t\t\t\t\t\tif(\n\t\t\t\t\t\t\t\t!elementMatchesSelector(se.element, opts.containment) &&\n\t\t\t\t\t\t\t\t!elementMatchesSelector(se.element, opts.containment + ' *')\n\t\t\t\t\t\t\t) return; // element is not within allowed containment\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar rect = se.element[0].getBoundingClientRect();\n\t\t\t\t\t\tvar center = {\n\t\t\t\t\t\t\tx: ~~(rect.left + rect.width/2),\n\t\t\t\t\t\t\ty: ~~(rect.top + rect.height/2)\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif(!se.container && // not the container element\n\t\t\t\t\t\t\t(se.element[0].scrollHeight || se.element[0].scrollWidth)){ // element is visible\n\t\t\t\t\t\t\tcandidates.push({\n\t\t\t\t\t\t\t\telement: se.element,\n\t\t\t\t\t\t\t\tq: (center.x - mouse.x)*(center.x - mouse.x) + (center.y - mouse.y)*(center.y - mouse.y),\n\t\t\t\t\t\t\t\tview: se.getPart(),\n\t\t\t\t\t\t\t\ttargetIndex: se.getIndex(),\n\t\t\t\t\t\t\t\tafter: shouldBeAfter(center, mouse, isGrid)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(se.container && !se.element[0].querySelector('[sv-element]:not(.sv-placeholder):not(.sv-source)')){ // empty container\n\t\t\t\t\t\t\tcandidates.push({\n\t\t\t\t\t\t\t\telement: se.element,\n\t\t\t\t\t\t\t\tq: (center.x - mouse.x)*(center.x - mouse.x) + (center.y - mouse.y)*(center.y - mouse.y),\n\t\t\t\t\t\t\t\tview: se.getPart(),\n\t\t\t\t\t\t\t\ttargetIndex: 0,\n\t\t\t\t\t\t\t\tcontainer: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tvar pRect = $placeholder[0].getBoundingClientRect();\n\t\t\t\t\tvar pCenter = {\n\t\t\t\t\t\tx: ~~(pRect.left + pRect.width/2),\n\t\t\t\t\t\ty: ~~(pRect.top + pRect.height/2)\n\t\t\t\t\t};\n\t\t\t\t\tcandidates.push({\n\t\t\t\t\t\tq: (pCenter.x - mouse.x)*(pCenter.x - mouse.x) + (pCenter.y - mouse.y)*(pCenter.y - mouse.y),\n\t\t\t\t\t\telement: $placeholder,\n\t\t\t\t\t\tplaceholder: true\n\t\t\t\t\t});\n\t\t\t\t\tcandidates.sort(function(a, b){\n\t\t\t\t\t\treturn a.q - b.q;\n\t\t\t\t\t});\n\n\t\t\t\t\tcandidates.forEach(function(cand, index){\n\t\t\t\t\t\tif(index === 0 && !cand.placeholder && !cand.container){\n\t\t\t\t\t\t\t$target = cand;\n\t\t\t\t\t\t\tcand.element.addClass('sv-candidate');\n\t\t\t\t\t\t\tif(cand.after)\n\t\t\t\t\t\t\t\tcand.element.after($placeholder);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tinsertElementBefore(cand.element, $placeholder);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(index === 0 && cand.container){\n\t\t\t\t\t\t\t$target = cand;\n\t\t\t\t\t\t\tcand.element.append($placeholder);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcand.element.removeClass('sv-candidate');\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tthis.$drop = function(originatingPart, index, options){\n\t\t\t\t\tif(!$placeholder) return;\n\n\t\t\t\t\tif(options.revert){\n\t\t\t\t\t\tvar placeholderRect = $placeholder[0].getBoundingClientRect();\n\t\t\t\t\t\tvar helperRect = $helper[0].getBoundingClientRect();\n\t\t\t\t\t\tvar distance = Math.sqrt(\n\t\t\t\t\t\t\tMath.pow(helperRect.top - placeholderRect.top, 2) +\n\t\t\t\t\t\t\tMath.pow(helperRect.left - placeholderRect.left, 2)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tvar duration = +options.revert*distance/200; // constant speed: duration depends on distance\n\t\t\t\t\t\tduration = Math.min(duration, +options.revert); // however it's not longer that options.revert\n\n\t\t\t\t\t\t['-webkit-', '-moz-', '-ms-', '-o-', ''].forEach(function(prefix){\n\t\t\t\t\t\t\tif(typeof $helper[0].style[prefix + 'transition'] !== \"undefined\")\n\t\t\t\t\t\t\t\t$helper[0].style[prefix + 'transition'] = 'all ' + duration + 'ms ease';\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsetTimeout(afterRevert, duration);\n\t\t\t\t\t\t$helper.css({\n\t\t\t\t\t\t\t'top': placeholderRect.top + document.body.scrollTop + 'px',\n\t\t\t\t\t\t\t'left': placeholderRect.left + document.body.scrollLeft + 'px'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tafterRevert();\n\n\t\t\t\t\tfunction afterRevert(){\n\t\t\t\t\t\tsortingInProgress = false;\n\t\t\t\t\t\t$placeholder.remove();\n\t\t\t\t\t\t$helper.remove();\n\t\t\t\t\t\t$original.removeClass('ng-hide');\n\n\t\t\t\t\t\tcandidates = void 0;\n\t\t\t\t\t\t$placeholder = void 0;\n\t\t\t\t\t\toptions = void 0;\n\t\t\t\t\t\t$helper = void 0;\n\t\t\t\t\t\t$original = void 0;\n\n\t\t\t\t\t\t// sv-on-stop callback\n\t\t\t\t\t\tonStop($scope, {\n\t\t\t\t\t\t\t$part: originatingPart.model(originatingPart.scope),\n\t\t\t\t\t\t\t$index: index,\n\t\t\t\t\t\t\t$item: originatingPart.model(originatingPart.scope)[index]\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif($target){\n\t\t\t\t\t\t\t$target.element.removeClass('sv-candidate');\n\t\t\t\t\t\t\tvar spliced = originatingPart.model(originatingPart.scope).splice(index, 1);\n\t\t\t\t\t\t\tvar targetIndex = $target.targetIndex;\n\t\t\t\t\t\t\tif($target.view === originatingPart && $target.targetIndex > index)\n\t\t\t\t\t\t\t\ttargetIndex--;\n\t\t\t\t\t\t\tif($target.after)\n\t\t\t\t\t\t\t\ttargetIndex++;\n\t\t\t\t\t\t\t$target.view.model($target.view.scope).splice(targetIndex, 0, spliced[0]);\n\n\t\t\t\t\t\t\t// sv-on-sort callback\n\t\t\t\t\t\t\tif($target.view !== originatingPart || index !== targetIndex)\n\t\t\t\t\t\t\t\tonSort($scope, {\n\t\t\t\t\t\t\t\t\t$partTo: $target.view.model($target.view.scope),\n\t\t\t\t\t\t\t\t\t$partFrom: originatingPart.model(originatingPart.scope),\n\t\t\t\t\t\t\t\t\t$item: spliced[0],\n\t\t\t\t\t\t\t\t\t$indexTo: targetIndex,\n\t\t\t\t\t\t\t\t\t$indexFrom: index\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$target = void 0;\n\n\t\t\t\t\t\t$scope.$root && $scope.$root.$$phase || $scope.$apply();\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.addToSortableElements = function(se){\n\t\t\t\t\tgetSortableElements(mapKey).push(se);\n\t\t\t\t};\n\t\t\t\tthis.removeFromSortableElements = function(se){\n\t\t\t\t\tvar elems = getSortableElements(mapKey);\n\t\t\t\t\tvar index = elems.indexOf(se);\n\t\t\t\t\tif(index > -1){\n\t\t\t\t\t\telems.splice(index, 1);\n\t\t\t\t\t\tif(elems.length === 0)\n\t\t\t\t\t\t\tremoveSortableElements(mapKey);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}]\n\t\t};\n\t}]);\n\n\tmodule.directive('svPart', ['$parse', function($parse){\n\t\treturn {\n\t\t\trestrict: 'A',\n\t\t\trequire: '^svRoot',\n\t\t\tcontroller: ['$scope', function($scope){\n\t\t\t\t$scope.$ctrl = this;\n\t\t\t\tthis.getPart = function(){\n\t\t\t\t\treturn $scope.part;\n\t\t\t\t};\n\t\t\t\tthis.$drop = function(index, options){\n\t\t\t\t\t$scope.$sortableRoot.$drop($scope.part, index, options);\n\t\t\t\t};\n\t\t\t}],\n\t\t\tscope: true,\n\t\t\tlink: function($scope, $element, $attrs, $sortable){\n\t\t\t\tif(!$attrs.svPart) throw new Error('no model provided');\n\t\t\t\tvar model = $parse($attrs.svPart);\n\t\t\t\tif(!model.assign) throw new Error('model not assignable');\n\n\t\t\t\t$scope.part = {\n\t\t\t\t\tid: $scope.$id,\n\t\t\t\t\telement: $element,\n\t\t\t\t\tmodel: model,\n\t\t\t\t\tscope: $scope\n\t\t\t\t};\n\t\t\t\t$scope.$sortableRoot = $sortable;\n\n\t\t\t\tvar sortablePart = {\n\t\t\t\t\telement: $element,\n\t\t\t\t\tgetPart: $scope.$ctrl.getPart,\n\t\t\t\t\tcontainer: true\n\t\t\t\t};\n\t\t\t\t$sortable.addToSortableElements(sortablePart);\n\t\t\t\t$scope.$on('$destroy', function(){\n\t\t\t\t\t$sortable.removeFromSortableElements(sortablePart);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}]);\n\n\tmodule.directive('svElement', ['$parse', function($parse){\n\t\treturn {\n\t\t\trestrict: 'A',\n\t\t\trequire: ['^svPart', '^svRoot'],\n\t\t\tcontroller: ['$scope', function($scope){\n\t\t\t\t$scope.$ctrl = this;\n\t\t\t}],\n\t\t\tlink: function($scope, $element, $attrs, $controllers){\n\t\t\t\tvar sortableElement = {\n\t\t\t\t\telement: $element,\n\t\t\t\t\tgetPart: $controllers[0].getPart,\n\t\t\t\t\tgetIndex: function(){\n\t\t\t\t\t\treturn $scope.$index;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t$controllers[1].addToSortableElements(sortableElement);\n\t\t\t\t$scope.$on('$destroy', function(){\n\t\t\t\t\t$controllers[1].removeFromSortableElements(sortableElement);\n\t\t\t\t});\n\n\t\t\t\tvar handle = $element;\n\t\t\t\thandle.on('mousedown touchstart', onMousedown);\n\t\t\t\t$scope.$watch('$ctrl.handle', function(customHandle){\n\t\t\t\t\tif(customHandle){\n\t\t\t\t\t\thandle.off('mousedown touchstart', onMousedown);\n\t\t\t\t\t\thandle = customHandle;\n\t\t\t\t\t\thandle.on('mousedown touchstart', onMousedown);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tvar helper;\n\t\t\t\t$scope.$watch('$ctrl.helper', function(customHelper){\n\t\t\t\t\tif(customHelper){\n\t\t\t\t\t\thelper = customHelper;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tvar placeholder;\n\t\t\t\t$scope.$watch('$ctrl.placeholder', function(customPlaceholder){\n\t\t\t\t\tif(customPlaceholder){\n\t\t\t\t\t\tplaceholder = customPlaceholder;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tvar body = angular.element(document.body);\n\t\t\t\tvar html = angular.element(document.documentElement);\n\n\t\t\t\tvar moveExecuted;\n\n\t\t\t\tfunction onMousedown(e){\n\t\t\t\t\ttouchFix(e);\n\n\t\t\t\t\tif($controllers[1].sortingInProgress()) return;\n\t\t\t\t\tif(e.button != 0 && e.type === 'mousedown') return;\n\n\t\t\t\t\tmoveExecuted = false;\n\t\t\t\t\tvar opts = $parse($attrs.svElement)($scope);\n\t\t\t\t\topts = angular.extend({}, {\n\t\t\t\t\t\ttolerance: 'pointer',\n\t\t\t\t\t\trevert: 200,\n\t\t\t\t\t\tcontainment: 'html'\n\t\t\t\t\t}, opts);\n\t\t\t\t\tif(opts.containment){\n\t\t\t\t\t\tvar containmentRect = closestElement.call($element, opts.containment)[0].getBoundingClientRect();\n\t\t\t\t\t}\n\n\t\t\t\t\tvar target = $element;\n\t\t\t\t\tvar clientRect = $element[0].getBoundingClientRect();\n\t\t\t\t\tvar clone;\n\n\t\t\t\t\tif(!helper) helper = $controllers[0].helper;\n\t\t\t\t\tif(!placeholder) placeholder = $controllers[0].placeholder;\n\t\t\t\t\tif(helper){\n\t\t\t\t\t\tclone = helper.clone();\n\t\t\t\t\t\tclone.removeClass('ng-hide');\n\t\t\t\t\t\tclone.css({\n\t\t\t\t\t\t\t'left': clientRect.left + document.body.scrollLeft + 'px',\n\t\t\t\t\t\t\t'top': clientRect.top + document.body.scrollTop + 'px'\n\t\t\t\t\t\t});\n\t\t\t\t\t\ttarget.addClass('sv-visibility-hidden');\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tclone = target.clone();\n\t\t\t\t\t\tclone.addClass('sv-helper').css({\n\t\t\t\t\t\t\t'left': clientRect.left + document.body.scrollLeft + 'px',\n\t\t\t\t\t\t\t'top': clientRect.top + document.body.scrollTop + 'px',\n\t\t\t\t\t\t\t'width': clientRect.width + 'px'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tclone[0].reposition = function(coords){\n\t\t\t\t\t\tvar targetLeft = coords.x;\n\t\t\t\t\t\tvar targetTop = coords.y;\n\t\t\t\t\t\tvar helperRect = clone[0].getBoundingClientRect();\n\n\t\t\t\t\t\tvar body = document.body;\n\n\t\t\t\t\t\tif(containmentRect){\n\t\t\t\t\t\t\tif(targetTop < containmentRect.top + body.scrollTop) // top boundary\n\t\t\t\t\t\t\t\ttargetTop = containmentRect.top + body.scrollTop;\n\t\t\t\t\t\t\tif(targetTop + helperRect.height > containmentRect.top + body.scrollTop + containmentRect.height) // bottom boundary\n\t\t\t\t\t\t\t\ttargetTop = containmentRect.top + body.scrollTop + containmentRect.height - helperRect.height;\n\t\t\t\t\t\t\tif(targetLeft < containmentRect.left + body.scrollLeft) // left boundary\n\t\t\t\t\t\t\t\ttargetLeft = containmentRect.left + body.scrollLeft;\n\t\t\t\t\t\t\tif(targetLeft + helperRect.width > containmentRect.left + body.scrollLeft + containmentRect.width) // right boundary\n\t\t\t\t\t\t\t\ttargetLeft = containmentRect.left + body.scrollLeft + containmentRect.width - helperRect.width;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.style.left = targetLeft - body.scrollLeft + 'px';\n\t\t\t\t\t\tthis.style.top = targetTop - body.scrollTop + 'px';\n\t\t\t\t\t};\n\n\t\t\t\t\tvar pointerOffset = {\n\t\t\t\t\t\tx: (e.clientX - clientRect.left)/clientRect.width,\n\t\t\t\t\t\ty: (e.clientY - clientRect.top)/clientRect.height\n\t\t\t\t\t};\n\t\t\t\t\thtml.addClass('sv-sorting-in-progress');\n\t\t\t\t\thtml.on('mousemove touchmove', onMousemove).on('mouseup touchend touchcancel', function mouseup(e){\n\t\t\t\t\t\thtml.off('mousemove touchmove', onMousemove);\n\t\t\t\t\t\thtml.off('mouseup touchend', mouseup);\n\t\t\t\t\t\thtml.removeClass('sv-sorting-in-progress');\n\t\t\t\t\t\tif(moveExecuted)\n\t\t\t\t\t\t\t$controllers[0].$drop($scope.$index, opts);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t$element.removeClass('sv-visibility-hidden');\n\t\t\t\t\t});\n\n\t\t\t\t\t// onMousemove(e);\n\t\t\t\t\tfunction onMousemove(e){\n\t\t\t\t\t\ttouchFix(e);\n\t\t\t\t\t\tif(!moveExecuted){\n\t\t\t\t\t\t\t$element.parent().prepend(clone);\n\t\t\t\t\t\t\tmoveExecuted = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$controllers[1].$moveUpdate(opts, {\n\t\t\t\t\t\t\tx: e.clientX,\n\t\t\t\t\t\t\ty: e.clientY,\n\t\t\t\t\t\t\toffset: pointerOffset\n\t\t\t\t\t\t}, clone, $element, placeholder, $controllers[0].getPart(), $scope.$index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}]);\n\n\tmodule.directive('svHandle', function(){\n\t\treturn {\n\t\t\trequire: '?^svElement',\n\t\t\tlink: function($scope, $element, $attrs, $ctrl){\n\t\t\t\tif($ctrl)\n\t\t\t\t\t$ctrl.handle = $element.add($ctrl.handle); // support multiple handles\n\t\t\t}\n\t\t};\n\t});\n\n\tmodule.directive('svHelper', function(){\n\t\treturn {\n\t\t\trequire: ['?^svPart', '?^svElement'],\n\t\t\tlink: function($scope, $element, $attrs, $ctrl){\n\t\t\t\t$element.addClass('sv-helper').addClass('ng-hide');\n\t\t\t\tif($ctrl[1])\n\t\t\t\t\t$ctrl[1].helper = $element;\n\t\t\t\telse if($ctrl[0])\n\t\t\t\t\t$ctrl[0].helper = $element;\n\t\t\t}\n\t\t};\n\t});\n\n\tmodule.directive('svPlaceholder', function(){\n\t\treturn {\n\t\t\trequire: ['?^svPart', '?^svElement'],\n\t\t\tlink: function($scope, $element, $attrs, $ctrl){\n\t\t\t\t$element.addClass('sv-placeholder').addClass('ng-hide');\n\t\t\t\tif($ctrl[1])\n\t\t\t\t\t$ctrl[1].placeholder = $element;\n\t\t\t\telse if($ctrl[0])\n\t\t\t\t\t$ctrl[0].placeholder = $element;\n\t\t\t}\n\t\t};\n\t});\n\n\tangular.element(document.head).append([\n\t\t'<style>' +\n\t\t'.sv-helper{' +\n\t\t\t'position: fixed !important;' +\n\t\t\t'z-index: 99999;' +\n\t\t\t'margin: 0 !important;' +\n\t\t'}' +\n\t\t'.sv-candidate{' +\n\t\t'}' +\n\t\t'.sv-placeholder{' +\n\t\t\t// 'opacity: 0;' +\n\t\t'}' +\n\t\t'.sv-sorting-in-progress{' +\n\t\t\t'-webkit-user-select: none;' +\n\t\t\t'-moz-user-select: none;' +\n\t\t\t'-ms-user-select: none;' +\n\t\t\t'user-select: none;' +\n\t\t'}' +\n\t\t'.sv-visibility-hidden{' +\n\t\t\t'visibility: hidden !important;' +\n\t\t\t'opacity: 0 !important;' +\n\t\t'}' +\n\t\t'</style>'\n\t].join(''));\n\n\tfunction touchFix(e){\n\t\tif(!('clientX' in e) && !('clientY' in e)) {\n\t\t\tvar touches = e.touches || e.originalEvent.touches;\n\t\t\tif(touches && touches.length) {\n\t\t\t\te.clientX = touches[0].clientX;\n\t\t\t\te.clientY = touches[0].clientY;\n\t\t\t}\n\t\t\te.preventDefault();\n\t\t}\n\t}\n\n\tfunction getPreviousSibling(element){\n\t\telement = element[0];\n\t\tif(element.previousElementSibling)\n\t\t\treturn angular.element(element.previousElementSibling);\n\t\telse{\n\t\t\tvar sib = element.previousSibling;\n\t\t\twhile(sib != null && sib.nodeType != 1)\n\t\t\t\tsib = sib.previousSibling;\n\t\t\treturn angular.element(sib);\n\t\t}\n\t}\n\n\tfunction insertElementBefore(element, newElement){\n\t\tvar prevSibl = getPreviousSibling(element);\n\t\tif(prevSibl.length > 0){\n\t\t\tprevSibl.after(newElement);\n\t\t}\n\t\telse{\n\t\t\telement.parent().prepend(newElement);\n\t\t}\n\t}\n\n\tvar dde = document.documentElement,\n\tmatchingFunction = dde.matches ? 'matches' :\n\t\t\t\t\t\tdde.matchesSelector ? 'matchesSelector' :\n\t\t\t\t\t\tdde.webkitMatches ? 'webkitMatches' :\n\t\t\t\t\t\tdde.webkitMatchesSelector ? 'webkitMatchesSelector' :\n\t\t\t\t\t\tdde.msMatches ? 'msMatches' :\n\t\t\t\t\t\tdde.msMatchesSelector ? 'msMatchesSelector' :\n\t\t\t\t\t\tdde.mozMatches ? 'mozMatches' :\n\t\t\t\t\t\tdde.mozMatchesSelector ? 'mozMatchesSelector' : null;\n\tif(matchingFunction == null)\n\t\tthrow 'This browser doesn\\'t support the HTMLElement.matches method';\n\n\tfunction elementMatchesSelector(element, selector){\n\t\tif(element instanceof angular.element) element = element[0];\n\t\tif(matchingFunction !== null)\n\t\t\treturn element[matchingFunction](selector);\n\t}\n\n\tvar closestElement = angular.element.prototype.closest || function (selector){\n\t\tvar el = this[0].parentNode;\n\t\twhile(el !== document.documentElement && !el[matchingFunction](selector))\n\t\t\tel = el.parentNode;\n\n\t\tif(el[matchingFunction](selector))\n\t\t\treturn angular.element(el);\n\t\telse\n\t\t\treturn angular.element();\n\t};\n\n\t/*\n\t\tSimple implementation of jQuery's .add method\n\t */\n\tif(typeof angular.element.prototype.add !== 'function'){\n\t\tangular.element.prototype.add = function(elem){\n\t\t\tvar i, res = angular.element();\n\t\t\telem = angular.element(elem);\n\t\t\tfor(i=0;i<this.length;i++){\n\t\t\t\tres.push(this[i]);\n\t\t\t}\n\t\t\tfor(i=0;i<elem.length;i++){\n\t\t\t\tres.push(elem[i]);\n\t\t\t}\n\t\t\treturn res;\n\t\t};\n\t}\n\n})(window, window.angular);","/* global angular */\n(function (window, document) {\n    'use strict';\n\n    /*\n     * AngularJS Toaster\n     * Version: 0.4.15\n     *\n     * Copyright 2013-2015 Jiri Kavulak.\n     * All Rights Reserved.\n     * Use, reproduction, distribution, and modification of this code is subject to the terms and\n     * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php\n     *\n     * Author: Jiri Kavulak\n     * Related to project of John Papa, Hans Fjällemark and Nguyễn Thiện Hùng (thienhung1989)\n     */\n\n    angular.module('toaster', []).constant(\n        'toasterConfig', {\n            'limit': 0,                   // limits max number of toasts\n            'tap-to-dismiss': true,\n\n            /* Options:\n             - Boolean false/true\n             'close-button': true\n             - object if not a boolean that allows you to\n             override showing the close button for each\n             icon-class value\n             'close-button': { 'toast-error': true, 'toast-info': false }\n             */\n            'close-button': false,\n            'newest-on-top': true, \n            //'fade-in': 1000,            // done in css\n            //'on-fade-in': undefined,    // not implemented\n            //'fade-out': 1000,           // done in css\n            //'on-fade-out': undefined,   // not implemented\n            //'extended-time-out': 1000,  // not implemented\n            'time-out': 5000, // Set timeOut and extendedTimeout to 0 to make it sticky\n            'icon-classes': {\n                error: 'toast-error',\n                info: 'toast-info',\n                wait: 'toast-wait',\n                success: 'toast-success',\n                warning: 'toast-warning'\n            },\n            'body-output-type': '', // Options: '', 'trustedHtml', 'template', 'templateWithData'\n            'body-template': 'toasterBodyTmpl.html',\n            'icon-class': 'toast-info',\n            'position-class': 'toast-top-right', // Options (see CSS):\n            // 'toast-top-full-width', 'toast-bottom-full-width', 'toast-center',\n            // 'toast-top-left', 'toast-top-center', 'toast-top-right',\n            // 'toast-bottom-left', 'toast-bottom-center', 'toast-bottom-right',\n            'title-class': 'toast-title',\n            'message-class': 'toast-message',\n            'prevent-duplicates': false,\n            'mouseover-timer-stop': true // stop timeout on mouseover and restart timer on mouseout\n        }\n    ).service(\n        'toaster', [\n            '$rootScope', 'toasterConfig', function ($rootScope, toasterConfig) {\n                this.pop = function (type, title, body, timeout, bodyOutputType, clickHandler, toasterId, showCloseButton, toastId, onHideCallback) {\n                    if (angular.isObject(type)) {\n                        var params = type; // Enable named parameters as pop argument\n                        this.toast = {\n                            type: params.type,\n                            title: params.title,\n                            body: params.body,\n                            timeout: params.timeout,\n                            bodyOutputType: params.bodyOutputType,\n                            clickHandler: params.clickHandler,\n                            showCloseButton: params.showCloseButton,\n                            uid: params.toastId,\n                            onHideCallback: params.onHideCallback\n                        };\n                        toastId = params.toastId;\n                        toasterId = params.toasterId;\n                    } else {\n                        this.toast = {\n                            type: type,\n                            title: title,\n                            body: body,\n                            timeout: timeout,\n                            bodyOutputType: bodyOutputType,\n                            clickHandler: clickHandler,\n                            showCloseButton: showCloseButton,\n                            uid: toastId,\n                            onHideCallback: onHideCallback\n                        };\n                    }\n                    $rootScope.$emit('toaster-newToast', toasterId, toastId);\n                };\n\n                this.clear = function (toasterId, toastId) {\n                    $rootScope.$emit('toaster-clearToasts', toasterId, toastId);\n                };\n\n                // Create one method per icon class, to allow to call toaster.info() and similar\n                for (var type in toasterConfig['icon-classes']) {\n                    this[type] = (function (toasterType) {\n                        return function (title, body, timeout, bodyOutputType, clickHandler, toasterId, showCloseButton, toastId,onHideCallback) {\n                            if (angular.isString(title)) {\n                                this.pop(\n                                    toasterType,\n                                    title,\n                                    body,\n                                    timeout,\n                                    bodyOutputType,\n                                    clickHandler,\n                                    toasterId,\n                                    showCloseButton,\n                                    toastId,\n                                    onHideCallback\n                                );\n                            } else { // 'title' is actually an object with options\n                                this.pop(angular.extend(title, { type: toasterType }));\n                            }\n                        };\n                    })(type);\n                }\n            }]\n    ).factory(\n        'toasterEventRegistry', [\n            '$rootScope', function ($rootScope) {\n                var deregisterNewToast = null, deregisterClearToasts = null, newToastEventSubscribers = [], clearToastsEventSubscribers = [], toasterFactory;\n\n                toasterFactory = {\n                    setup: function () {\n                        if (!deregisterNewToast) {\n                            deregisterNewToast = $rootScope.$on(\n                                'toaster-newToast', function (event, toasterId, toastId) {\n                                    for (var i = 0, len = newToastEventSubscribers.length; i < len; i++) {\n                                        newToastEventSubscribers[i](event, toasterId, toastId);\n                                    }\n                                }\n                            );\n                        }\n\n                        if (!deregisterClearToasts) {\n                            deregisterClearToasts = $rootScope.$on(\n                                'toaster-clearToasts', function (event, toasterId, toastId) {\n                                    for (var i = 0, len = clearToastsEventSubscribers.length; i < len; i++) {\n                                        clearToastsEventSubscribers[i](event, toasterId, toastId);\n                                    }\n                                }\n                            );\n                        }\n                    },\n\n                    subscribeToNewToastEvent: function (onNewToast) {\n                        newToastEventSubscribers.push(onNewToast);\n                    },\n                    subscribeToClearToastsEvent: function (onClearToasts) {\n                        clearToastsEventSubscribers.push(onClearToasts);\n                    },\n                    unsubscribeToNewToastEvent: function (onNewToast) {\n                        var index = newToastEventSubscribers.indexOf(onNewToast);\n                        if (index >= 0) {\n                            newToastEventSubscribers.splice(index, 1);\n                        }\n\n                        if (newToastEventSubscribers.length === 0) {\n                            deregisterNewToast();\n                            deregisterNewToast = null;\n                        }\n                    },\n                    unsubscribeToClearToastsEvent: function (onClearToasts) {\n                        var index = clearToastsEventSubscribers.indexOf(onClearToasts);\n                        if (index >= 0) {\n                            clearToastsEventSubscribers.splice(index, 1);\n                        }\n\n                        if (clearToastsEventSubscribers.length === 0) {\n                            deregisterClearToasts();\n                            deregisterClearToasts = null;\n                        }\n                    }\n                };\n                return {\n                    setup: toasterFactory.setup,\n                    subscribeToNewToastEvent: toasterFactory.subscribeToNewToastEvent,\n                    subscribeToClearToastsEvent: toasterFactory.subscribeToClearToastsEvent,\n                    unsubscribeToNewToastEvent: toasterFactory.unsubscribeToNewToastEvent,\n                    unsubscribeToClearToastsEvent: toasterFactory.unsubscribeToClearToastsEvent\n                };\n            }]\n    ).directive(\n        'toasterContainer', [\n            '$parse', '$rootScope', '$interval', '$sce', 'toasterConfig', 'toaster', 'toasterEventRegistry',\n            function ($parse, $rootScope, $interval, $sce, toasterConfig, toaster, toasterEventRegistry) {\n                return {\n                    replace: true,\n                    restrict: 'EA',\n                    scope: true, // creates an internal scope for this directive (one per directive instance)\n                    link: function (scope, elm, attrs) {\n                        var id = 0, mergedConfig;\n\n                        // Merges configuration set in directive with default one\n                        mergedConfig = angular.extend({}, toasterConfig, scope.$eval(attrs.toasterOptions));\n\n                        scope.config = {\n                            toasterId: mergedConfig['toaster-id'],\n                            position: mergedConfig['position-class'],\n                            title: mergedConfig['title-class'],\n                            message: mergedConfig['message-class'],\n                            tap: mergedConfig['tap-to-dismiss'],\n                            closeButton: mergedConfig['close-button'],\n                            animation: mergedConfig['animation-class'],\n                            mouseoverTimer: mergedConfig['mouseover-timer-stop']\n                        };\n\n                        scope.$on(\n                            \"$destroy\", function () {\n                                toasterEventRegistry.unsubscribeToNewToastEvent(scope._onNewToast);\n                                toasterEventRegistry.unsubscribeToClearToastsEvent(scope._onClearToasts);\n                            }\n                        );\n\n                        function setTimeout(toast, time) {\n                            toast.timeoutPromise = $interval(\n                                function () {\n                                    scope.removeToast(toast.id);\n                                }, time, 1\n                            );\n                        }\n\n                        scope.configureTimer = function (toast) {\n                            var timeout = angular.isNumber(toast.timeout) ? toast.timeout : mergedConfig['time-out'];\n                            if (typeof timeout === \"object\") timeout = timeout[toast.type];\n                            if (timeout > 0) {\n                                setTimeout(toast, timeout);\n                            }\n                        };\n\n                        function addToast(toast, toastId) {\n                            toast.type = mergedConfig['icon-classes'][toast.type];\n                            if (!toast.type) {\n                                toast.type = mergedConfig['icon-class'];\n                            }\n\n                            if (mergedConfig['prevent-duplicates'] === true) {\n                                // Prevent adding duplicate toasts if it's set\n                                if (isUndefinedOrNull(toastId)) {\n                                    if (scope.toasters.length > 0 && scope.toasters[scope.toasters.length - 1].body === toast.body) {\n                                        return;\n                                    }\n                                } else {\n                                    var i, len;\n                                    for (i = 0, len = scope.toasters.length; i < len; i++) {\n                                        if (scope.toasters[i].uid === toastId) {\n                                            removeToast(i);\n                                            // update loop\n                                            i--;\n                                            len = scope.toasters.length;\n                                        }\n                                    }\n                                }\n                            }\n\n                            toast.id = ++id;\n                            // Sure uid defined\n                            if (!isUndefinedOrNull(toastId)) {\n                                toast.uid = toastId;\n                            }\n\n                            // set the showCloseButton property on the toast so that\n                            // each template can bind directly to the property to show/hide\n                            // the close button\n                            var closeButton = mergedConfig['close-button'];\n\n                            // if toast.showCloseButton is a boolean value,\n                            // it was specifically overriden in the pop arguments\n                            if (typeof toast.showCloseButton === \"boolean\") {\n\n                            } else if (typeof closeButton === \"boolean\") {\n                                toast.showCloseButton = closeButton;\n                            } else if (typeof closeButton === \"object\") {\n                                var closeButtonForType = closeButton[toast.type];\n\n                                if (typeof closeButtonForType !== \"undefined\" && closeButtonForType !== null) {\n                                    toast.showCloseButton = closeButtonForType;\n                                }\n                            } else {\n                                // if an option was not set, default to false.\n                                toast.showCloseButton = false;\n                            }\n\n                            // Set the toast.bodyOutputType to the default if it isn't set\n                            toast.bodyOutputType = toast.bodyOutputType || mergedConfig['body-output-type'];\n                            switch (toast.bodyOutputType) {\n                                case 'trustedHtml':\n                                    toast.html = $sce.trustAsHtml(toast.body);\n                                    break;\n                                case 'template':\n                                    toast.bodyTemplate = toast.body || mergedConfig['body-template'];\n                                    break;\n                                case 'templateWithData':\n                                    var fcGet = $parse(toast.body || mergedConfig['body-template']);\n                                    var templateWithData = fcGet(scope);\n                                    toast.bodyTemplate = templateWithData.template;\n                                    toast.data = templateWithData.data;\n                                    break;\n                            }\n\n                            scope.configureTimer(toast);\n                            if (mergedConfig['newest-on-top'] === true) {\n                                scope.toasters.unshift(toast);\n                                if (mergedConfig['limit'] > 0 && scope.toasters.length > mergedConfig['limit']) {\n                                    scope.toasters.pop();\n                                }\n                            } else {\n                                scope.toasters.push(toast);\n                                if (mergedConfig['limit'] > 0 && scope.toasters.length > mergedConfig['limit']) {\n                                    scope.toasters.shift();\n                                }\n                            }\n                        }\n\n                        scope.removeToast = function (id) {\n                            var i, len, toast;\n                            for (i = 0, len = scope.toasters.length; i < len; i++) {\n                                if (scope.toasters[i].id === id) {\n                                    removeToast(i);\n                                    break;\n                                }\n                            }\n                        };\n\n                        function removeToast(toastIndex) {\n                            var toast = scope.toasters[toastIndex];\n                            if (toast) {\n                                if (toast.timeoutPromise) {\n                                    $interval.cancel(toast.timeoutPromise);\n                                }\n                                scope.toasters.splice(toastIndex, 1);\n                                \n                                if (angular.isFunction(toast.onHideCallback)) {\n                                    toast.onHideCallback();\n                                }\n                            }\n                        }\n\n                        function removeAllToasts(toastId) {\n                            for (var i = scope.toasters.length - 1; i >= 0; i--) {\n                                if (isUndefinedOrNull(toastId)) {\n                                    removeToast(i);\n                                } else {\n                                    if (scope.toasters[i].uid == toastId) {\n                                        removeToast(i);\n                                    }\n                                }\n                            }\n                        }\n\n                        scope.toasters = [];\n\n                        function isUndefinedOrNull(val) {\n                            return angular.isUndefined(val) || val === null\n                        }\n\n                        scope._onNewToast = function (event, toasterId, toastId) {\n                            // Compatibility: if toaster has no toasterId defined, and if call to display\n                            // hasn't either, then the request is for us\n\n                            if ((isUndefinedOrNull(scope.config.toasterId) && isUndefinedOrNull(toasterId)) || (!isUndefinedOrNull(scope.config.toasterId) && !isUndefinedOrNull(toasterId) && scope.config.toasterId == toasterId)) {\n                                addToast(toaster.toast, toastId);\n                            }\n                        };\n                        scope._onClearToasts = function (event, toasterId, toastId) {\n                            // Compatibility: if toaster has no toasterId defined, and if call to display\n                            // hasn't either, then the request is for us\n                            if (toasterId == '*' || (isUndefinedOrNull(scope.config.toasterId) && isUndefinedOrNull(toasterId)) || (!isUndefinedOrNull(scope.config.toasterId) && !isUndefinedOrNull(toasterId) && scope.config.toasterId == toasterId)) {\n                                removeAllToasts(toastId);\n                            }\n                        };\n\n                        toasterEventRegistry.setup();\n\n                        toasterEventRegistry.subscribeToNewToastEvent(scope._onNewToast);\n                        toasterEventRegistry.subscribeToClearToastsEvent(scope._onClearToasts);\n                    },\n                    controller: [\n                        '$scope', '$element', '$attrs', function ($scope, $element, $attrs) {\n                            // Called on mouseover\n                            $scope.stopTimer = function (toast) {\n                                if ($scope.config.mouseoverTimer === true) {\n                                    if (toast.timeoutPromise) {\n                                        $interval.cancel(toast.timeoutPromise);\n                                        toast.timeoutPromise = null;\n                                    }\n                                }\n                            };\n\n                            // Called on mouseout\n                            $scope.restartTimer = function (toast) {\n                                if ($scope.config.mouseoverTimer === true) {\n                                    if (!toast.timeoutPromise) {\n                                        $scope.configureTimer(toast);\n                                    }\n                                } else if (toast.timeoutPromise === null) {\n                                    $scope.removeToast(toast.id);\n                                }\n                            };\n\n                            $scope.click = function (toast, isCloseButton) {\n                                if ($scope.config.tap === true || (toast.showCloseButton === true && isCloseButton === true)) {\n                                    var removeToast = true;\n                                    if (toast.clickHandler) {\n                                        if (angular.isFunction(toast.clickHandler)) {\n                                            removeToast = toast.clickHandler(toast, isCloseButton);\n                                        } else if (angular.isFunction($scope.$parent.$eval(toast.clickHandler))) {\n                                            removeToast = $scope.$parent.$eval(toast.clickHandler)(toast, isCloseButton);\n                                        } else {\n                                            console.log(\"TOAST-NOTE: Your click handler is not inside a parent scope of toaster-container.\");\n                                        }\n                                    }\n                                    if (removeToast) {\n                                        $scope.removeToast(toast.id);\n                                    }\n                                }\n                            };\n                        }],\n                    template: '<div id=\"toast-container\" ng-class=\"[config.position, config.animation]\">' + '<div ng-repeat=\"toaster in toasters\" class=\"toast\" ng-class=\"toaster.type\" ng-click=\"click(toaster)\" ng-mouseover=\"stopTimer(toaster)\" ng-mouseout=\"restartTimer(toaster)\">' + '<button type=\"button\" class=\"toast-close-button\" ng-show=\"toaster.showCloseButton\" ng-click=\"click(toaster, true)\">&times;</button>' + '<div ng-class=\"config.title\">{{toaster.title}}</div>' + '<div ng-class=\"config.message\" ng-switch on=\"toaster.bodyOutputType\">' + '<div ng-switch-when=\"trustedHtml\" ng-bind-html=\"toaster.html\"></div>' + '<div ng-switch-when=\"template\"><div ng-include=\"toaster.bodyTemplate\"></div></div>' + '<div ng-switch-when=\"templateWithData\"><div ng-include=\"toaster.bodyTemplate\"></div></div>' + '<div ng-switch-default >{{toaster.body}}</div>' + '</div>' + '</div>' + '</div>'\n                };\n            }]\n    );\n})(window, document);"],"sourceRoot":"/source/"}